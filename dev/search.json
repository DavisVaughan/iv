[{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@rstudio.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 ivs authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_groups","dir":"Articles","previous_headings":"","what":"iv_groups()","title":"Stack Overflow Examples","text":"Flatten / Merge overlapping time periods group Merge millisecond date-time periods Merge overlapping date-time intervals group Group hospital patient stay dates Merge overlaps within groups Detect self-overlaps within groups","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_identify_group","dir":"Articles","previous_headings":"","what":"iv_identify_group()","title":"Stack Overflow Examples","text":"Identify overlapping date ranges Determine date interval overlaps date intervals Identify active maintanence types","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_identify_splits","dir":"Articles","previous_headings":"","what":"iv_identify_splits()","title":"Stack Overflow Examples","text":"Find overlaps create new rows overlap","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_count_between","dir":"Articles","previous_headings":"","what":"iv_count_between()","title":"Stack Overflow Examples","text":"Aggregate rolling enrollment month Another aggregate rolling enrollment month","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_count_overlaps","dir":"Articles","previous_headings":"","what":"iv_count_overlaps()","title":"Stack Overflow Examples","text":"Detect self-overlaps","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_count_includes","dir":"Articles","previous_headings":"","what":"iv_count_includes()","title":"Stack Overflow Examples","text":"Track rolling monthly disease prevalence","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_set_complement","dir":"Articles","previous_headings":"","what":"iv_set_complement()","title":"Stack Overflow Examples","text":"Find ranges dates apartment empty","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_locate_overlaps","dir":"Articles","previous_headings":"","what":"iv_locate_overlaps()","title":"Stack Overflow Examples","text":"Locate self overlaps compute proportion within overlaps","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/examples.html","id":"iv_overlaps","dir":"Articles","previous_headings":"","what":"iv_overlaps()","title":"Stack Overflow Examples","text":"Detecting overlaps two sets ranges","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to ivs","text":"ivs (said, “eye-vees”) package dedicated working intervals generic way. introduces new type, interval vector, generally referred iv. iv generally created two parallel vectors representing starts ends intervals, like : neat thing interval vectors generic, can create comparable type supported vctrs. example, integer64 type bit64 package: year-month type clock: rest vignette explores useful things can ivs.","code":"# Interval vector of integers iv(1:5, 7:11) #> <iv<integer>[5]> #> [1] [1, 7)  [2, 8)  [3, 9)  [4, 10) [5, 11)  # Interval vector of dates starts <- as.Date(\"2019-01-01\") + 0:2 ends <- starts + c(2, 5, 10)  iv(starts, ends) #> <iv<date>[3]> #> [1] [2019-01-01, 2019-01-03) [2019-01-02, 2019-01-07) [2019-01-03, 2019-01-13) start <- bit64::as.integer64(\"900000000000\") end <- start + 1234  iv(start, end) #> <iv<integer64>[1]> #> [1] [900000000000, 900000001234) start <- year_month_day(c(2019, 2020), c(1, 3)) end <- year_month_day(c(2020, 2020), c(2, 6))  iv(start, end) #> <iv<year_month_day<month>>[2]> #> [1] [2019-01, 2020-02) [2020-03, 2020-06)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"structure","dir":"Articles","previous_headings":"","what":"Structure","title":"Introduction to ivs","text":"mentioned , ivs created two parallel vectors representing starts ends intervals. can access starts iv_start() ends iv_end(): can use iv column data frame tibble ’ll work just fine!","code":"x <- iv(1:3, 4:6) x #> <iv<integer>[3]> #> [1] [1, 4) [2, 5) [3, 6) iv_start(x) #> [1] 1 2 3 iv_end(x) #> [1] 4 5 6 tibble(x = x) #> # A tibble: 3 × 1 #>           x #>   <iv<int>> #> 1    [1, 4) #> 2    [2, 5) #> 3    [3, 6)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"right-open-intervals","dir":"Articles","previous_headings":"Structure","what":"Right-open intervals","title":"Introduction to ivs","text":"interval type supported ivs right-open interval, .e. [, b). might seem restrictive, rarely ends problem practice, often aligns easiest way express particular interval. example, consider interval spans entire day 2019-01-02. wanted represent interval second precision right-open interval, ’d [2019-01-02 00:00:00, 2019-01-03 00:00:00). nicely captures exclusive “end” interval start next day. also means exactly aligns start next day’s interval, [2019-01-03 00:00:00, 2019-01-04 00:00:00). wanted represent closed interval, might [2019-01-02 00:00:00, 2019-01-02 23:59:59]. bit awkward, can also cause issues precision changes! Say wanted precision interval second level precision millisecond precision. right-open interval wouldn’t change since end interval set 2019-01-03 00:00:00 anything fair game. closed interval can’t naively changed 2019-01-02 23:59:59 2019-01-02 23:59:59.000, ’d lose 999 milliseconds last second. Extra care taken set milliseconds 2019-01-02 23:59:59.999. still aren’t convinced, ’d encourage take look resources also advocate right-open intervals: numbering start 0 two Stack Overflow posts (1, 2) expand paper Time intervals ranges half-open","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"empty-intervals","dir":"Articles","previous_headings":"Structure","what":"Empty intervals","title":"Introduction to ivs","text":"ivs, required start < end generating interval vector. means intervals like [5, 2) invalid, also means “empty” interval [5, 5) also invalid. Practically, ’ve found attempting allow ends resulting implementation headaches anything else, don’t end many uses.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"finding-overlaps","dir":"Articles","previous_headings":"","what":"Finding overlaps","title":"Introduction to ivs","text":"One compelling reasons use package tries make finding overlapping intervals easy possible. iv_locate_overlaps() takes two ivs returns data frame containing information overlap. works somewhat like base::match() element needles, looks match haystack. Unlike match(), actually returns overlaps rather just first. $needles column result integer vector showing slice needles generate intervals overlap intervals haystack described $haystack column. needle doesn’t overlap intervals haystack, NA location returned. easy way align needles haystack using information pass everything iv_align(), automatically perform slicing store results another data frame: just wanted know interval needles overlapped interval haystack, can use iv_overlaps(), returns logical vector. default, iv_locate_overlaps() detect kind overlap two inputs, various types overlaps can detect. example, can check needles “contains” haystack: ’ve also used no_match = \"drop\" drop needles don’t matching overlaps. can also check reverse, .e. needles “within” haystack:","code":"# iv_pairs() is a useful way to create small ivs from individual intervals needles <- iv_pairs(c(1, 5), c(3, 7), c(10, 12)) needles #> <iv<double>[3]> #> [1] [1, 5)   [3, 7)   [10, 12)  haystack <- iv_pairs(c(0, 6), c(13, 15), c(0, 2), c(7, 8), c(4, 5)) haystack #> <iv<double>[5]> #> [1] [0, 6)   [13, 15) [0, 2)   [7, 8)   [4, 5)  locations <- iv_locate_overlaps(needles, haystack) locations #>   needles haystack #> 1       1        1 #> 2       1        3 #> 3       1        5 #> 4       2        1 #> 5       2        5 #> 6       3       NA iv_align(needles, haystack, locations = locations) #>    needles haystack #> 1   [1, 5)   [0, 6) #> 2   [1, 5)   [0, 2) #> 3   [1, 5)   [4, 5) #> 4   [3, 7)   [0, 6) #> 5   [3, 7)   [4, 5) #> 6 [10, 12) [NA, NA) iv_overlaps(needles, haystack) #> [1]  TRUE  TRUE FALSE locations <- iv_locate_overlaps(   needles,    haystack,    type = \"contains\",    no_match = \"drop\" )  iv_align(needles, haystack, locations = locations) #>   needles haystack #> 1  [1, 5)   [4, 5) #> 2  [3, 7)   [4, 5) locations <- iv_locate_overlaps(   needles,    haystack,    type = \"within\",    no_match = \"drop\" )  iv_align(needles, haystack, locations = locations) #>   needles haystack #> 1  [1, 5)   [0, 6)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"precedes-follows","dir":"Articles","previous_headings":"Finding overlaps","what":"Precedes / Follows","title":"Introduction to ivs","text":"Two functions related iv_locate_overlaps() iv_locate_precedes() iv_locate_follows(). returns data frame structure iv_locate_overlaps(), can use iv_align(). interested closest interval haystack needle precedes follows, set closest = TRUE.","code":"# Where does `needles` precede `haystack`? locations <- iv_locate_precedes(needles, haystack) locations #>   needles haystack #> 1       1        2 #> 2       1        4 #> 3       2        2 #> 4       2        4 #> 5       3        2 iv_align(needles, haystack, locations = locations) #>    needles haystack #> 1   [1, 5) [13, 15) #> 2   [1, 5)   [7, 8) #> 3   [3, 7) [13, 15) #> 4   [3, 7)   [7, 8) #> 5 [10, 12) [13, 15) # Where does `needles` follow `haystack`? locations <- iv_locate_follows(needles, haystack)  iv_align(needles, haystack, locations = locations) #>    needles haystack #> 1   [1, 5) [NA, NA) #> 2   [3, 7)   [0, 2) #> 3 [10, 12)   [0, 6) #> 4 [10, 12)   [0, 2) #> 5 [10, 12)   [7, 8) #> 6 [10, 12)   [4, 5) locations <- iv_locate_follows(   needles = needles,    haystack = haystack,    closest = TRUE,   no_match = \"drop\" )  iv_align(needles, haystack, locations = locations) #>    needles haystack #> 1   [3, 7)   [0, 2) #> 2 [10, 12)   [7, 8)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"allens-interval-algebra","dir":"Articles","previous_headings":"Finding overlaps","what":"Allen’s Interval Algebra","title":"Introduction to ivs","text":"Maintaining Knowledge Temporal Intervals great paper James Allen outlines interval algebra completely describes two intervals related (.e. one interval precedes, overlaps, met-another interval). paper describes 13 relations make algebra, faithfully implemented iv_locate_relates() iv_relates(). relations extremely useful distinct (.e. two intervals can related exactly 1 13 relations), bit restrictive practically useful. iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows() combine multiple individual relations three broad ideas find useful. want learn , ’d encourage read help documentation iv_locate_relates().","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"between-ness","dir":"Articles","previous_headings":"Finding overlaps","what":"Between-ness","title":"Introduction to ivs","text":"Often just want know vector values falls bounds interval. particularly common dates, might want know sale made corresponded interval range commercial run. can check sale made commercial run iv_between(), works like %% similar iv_overlaps(): can find commercials airing sale made iv_locate_between() iv_align(): aren’t looking %%-like behavior iv_between(), instead want pairwise detect whether one value falls interval , can use iv_pairwise_between(): Keep mind intervals half-open, 12 doesn’t fall interval [10, 12)! different dplyr::().","code":"sales <- as.Date(c(\"2019-01-01\", \"2020-05-10\", \"2020-06-10\"))  commercial_starts <- as.Date(c(   \"2019-10-12\", \"2020-04-01\", \"2020-06-01\", \"2021-05-10\" )) commercial_ends <- commercial_starts + 90  commercials <- iv(commercial_starts, commercial_ends)  sales #> [1] \"2019-01-01\" \"2020-05-10\" \"2020-06-10\" commercials #> <iv<date>[4]> #> [1] [2019-10-12, 2020-01-10) [2020-04-01, 2020-06-30) [2020-06-01, 2020-08-30) #> [4] [2021-05-10, 2021-08-08) tibble(sales = sales) %>%   mutate(commercial_running = iv_between(sales, commercials)) #> # A tibble: 3 × 2 #>   sales      commercial_running #>   <date>     <lgl>              #> 1 2019-01-01 FALSE              #> 2 2020-05-10 TRUE               #> 3 2020-06-10 TRUE iv_align(sales, commercials, locations = iv_locate_between(sales, commercials)) #>      needles                 haystack #> 1 2019-01-01                 [NA, NA) #> 2 2020-05-10 [2020-04-01, 2020-06-30) #> 3 2020-06-10 [2020-04-01, 2020-06-30) #> 4 2020-06-10 [2020-06-01, 2020-08-30) x <- c(1, 5, 10, 12) x #> [1]  1  5 10 12  y <- iv_pairs(c(0, 6), c(7, 9), c(10, 12), c(10, 12)) y #> <iv<double>[4]> #> [1] [0, 6)   [7, 9)   [10, 12) [10, 12)  iv_pairwise_between(x, y) #> [1]  TRUE FALSE  TRUE FALSE"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"counting-overlaps","dir":"Articles","previous_headings":"","what":"Counting overlaps","title":"Introduction to ivs","text":"Sometimes just need counts number overlaps rather actual locations . example, say business subscription service ’d like compute rolling monthly count total number subscriptions active (.e. January 2019, many subscriptions active?). Customers allowed one subscription active , may cancel reactivate time. customer active point month, counted month. Even though day precision information, actually need month precision intervals answer question. ’ll use calendar_narrow() clock convert \"day\" precision dates \"month\" precision ones. ’ll also add 1 month end intervals reflect fact end month open (remember, ivs half-open). answer question, going need create sequential vector months span entire range intervals. starts smallest start goes largest end. end half-open, won’t hits month, won’t include . Now need add column months represent number subscriptions active month. can use iv_count_between(). works like iv_between() iv_locate_between() returns integer vector corresponding number times -th “needle” value fell values “haystack”. also iv_count_overlaps(), iv_count_precedes(), iv_count_follows() working two ivs .","code":"enrollments <- tribble(   ~name,      ~start,          ~end,   \"Amy\",      \"1, Jan, 2017\",  \"30, Jul, 2018\",   \"Franklin\", \"1, Jan, 2017\",  \"19, Feb, 2017\",   \"Franklin\", \"5, Jun, 2017\",  \"4, Feb, 2018\",   \"Franklin\", \"21, Oct, 2018\", \"9, Mar, 2019\",   \"Samir\",    \"1, Jan, 2017\",  \"4, Feb, 2017\",   \"Samir\",    \"5, Apr, 2017\",  \"12, Jun, 2018\" )  # Parse these into \"day\" precision year-month-day objects enrollments <- enrollments %>%   mutate(     start = year_month_day_parse(start, format = \"%d, %b, %Y\"),     end = year_month_day_parse(end, format = \"%d, %b, %Y\"),   )  enrollments #> # A tibble: 6 × 3 #>   name     start      end        #>   <chr>    <ymd<day>> <ymd<day>> #> 1 Amy      2017-01-01 2018-07-30 #> 2 Franklin 2017-01-01 2017-02-19 #> 3 Franklin 2017-06-05 2018-02-04 #> 4 Franklin 2018-10-21 2019-03-09 #> 5 Samir    2017-01-01 2017-02-04 #> 6 Samir    2017-04-05 2018-06-12 enrollments <- enrollments %>%   mutate(     start = calendar_narrow(start, \"month\"),     end = calendar_narrow(end, \"month\") + 1L   )  enrollments #> # A tibble: 6 × 3 #>   name     start        end          #>   <chr>    <ymd<month>> <ymd<month>> #> 1 Amy      2017-01      2018-08      #> 2 Franklin 2017-01      2017-03      #> 3 Franklin 2017-06      2018-03      #> 4 Franklin 2018-10      2019-04      #> 5 Samir    2017-01      2017-03      #> 6 Samir    2017-04      2018-07  enrollments <- enrollments %>%   mutate(active = iv(start, end), .keep = \"unused\")  enrollments #> # A tibble: 6 × 2 #>   name                 active #>   <chr>      <iv<ymd<month>>> #> 1 Amy      [2017-01, 2018-08) #> 2 Franklin [2017-01, 2017-03) #> 3 Franklin [2017-06, 2018-03) #> 4 Franklin [2018-10, 2019-04) #> 5 Samir    [2017-01, 2017-03) #> 6 Samir    [2017-04, 2018-07) bounds <- range(enrollments$active) lower <- iv_start(bounds[[1]]) upper <- iv_end(bounds[[2]]) - 1L  months <- tibble(month = seq(lower, upper, by = 1))  months #> # A tibble: 27 × 1 #>    month        #>    <ymd<month>> #>  1 2017-01      #>  2 2017-02      #>  3 2017-03      #>  4 2017-04      #>  5 2017-05      #>  6 2017-06      #>  7 2017-07      #>  8 2017-08      #>  9 2017-09      #> 10 2017-10      #> # … with 17 more rows months %>%   mutate(count = iv_count_between(month, enrollments$active)) %>%   print(n = Inf) #> # A tibble: 27 × 2 #>    month        count #>    <ymd<month>> <int> #>  1 2017-01          3 #>  2 2017-02          3 #>  3 2017-03          1 #>  4 2017-04          2 #>  5 2017-05          2 #>  6 2017-06          3 #>  7 2017-07          3 #>  8 2017-08          3 #>  9 2017-09          3 #> 10 2017-10          3 #> 11 2017-11          3 #> 12 2017-12          3 #> 13 2018-01          3 #> 14 2018-02          3 #> 15 2018-03          2 #> 16 2018-04          2 #> 17 2018-05          2 #> 18 2018-06          2 #> 19 2018-07          1 #> 20 2018-08          0 #> 21 2018-09          0 #> 22 2018-10          1 #> 23 2018-11          1 #> 24 2018-12          1 #> 25 2019-01          1 #> 26 2019-02          1 #> 27 2019-03          1"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"grouping-by-overlaps","dir":"Articles","previous_headings":"","what":"Grouping by overlaps","title":"Introduction to ivs","text":"One common operation working interval vectors merging overlapping intervals within single interval vector. removes redundant information, still maintaining full range covered iv. , can use iv_groups() computes minimal set interval “groups” contain intervals x. default, grouped abutting intervals aren’t considered overlap also don’t values . don’t want , use abutting argument.","code":"x <- iv_pairs(c(1, 5), c(5, 7), c(9, 11), c(10, 13), c(12, 13)) x #> <iv<double>[5]> #> [1] [1, 5)   [5, 7)   [9, 11)  [10, 13) [12, 13)  iv_groups(x) #> <iv<double>[2]> #> [1] [1, 7)  [9, 13) iv_groups(x, abutting = FALSE) #> <iv<double>[3]> #> [1] [1, 5)  [5, 7)  [9, 13)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"with-group_by","dir":"Articles","previous_headings":"Grouping by overlaps","what":"With group_by()","title":"Introduction to ivs","text":"Grouping overlapping intervals often useful way create new variable group dplyr::group_by(). example, consider following problem multiple users racking costs across multiple systems. date ranges represent range corresponding cost accrued , ranges don’t overlap given (user, system) pair. Now let’s say don’t care system anymore, instead want sum costs overlapping date ranges particular user. iv_groups() can give us idea non-overlapping ranges user: can sum costs? , need turn iv_identify_group() allows us identify group range falls . give us something group can sum costs.","code":"costs <- tribble(   ~user, ~system, ~from, ~to, ~cost,   1L, \"a\", \"2019-01-01\", \"2019-01-05\", 200.5,   1L, \"a\", \"2019-01-12\", \"2019-01-13\", 15.6,   1L, \"b\", \"2019-01-03\", \"2019-01-10\", 500.3,   2L, \"a\", \"2019-01-02\", \"2019-01-03\", 25.6,   2L, \"c\", \"2019-01-03\", \"2019-01-04\", 30,   2L, \"c\", \"2019-01-05\", \"2019-01-07\", 66.2 )  costs <- costs %>%   mutate(     from = as.Date(from),     to = as.Date(to)   ) %>%   mutate(range = iv(from, to), .keep = \"unused\")  costs #> # A tibble: 6 × 4 #>    user system  cost                    range #>   <int> <chr>  <dbl>               <iv<date>> #> 1     1 a      200.  [2019-01-01, 2019-01-05) #> 2     1 a       15.6 [2019-01-12, 2019-01-13) #> 3     1 b      500.  [2019-01-03, 2019-01-10) #> 4     2 a       25.6 [2019-01-02, 2019-01-03) #> 5     2 c       30   [2019-01-03, 2019-01-04) #> 6     2 c       66.2 [2019-01-05, 2019-01-07) costs %>%   group_by(user) %>%   summarise(range = iv_groups(range), .groups = \"drop\") #> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #> dplyr 1.1.0. #> ℹ Please use `reframe()` instead. #> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` #>   always returns an ungrouped data frame and adjust accordingly. #> # A tibble: 4 × 2 #>    user                    range #>   <int>               <iv<date>> #> 1     1 [2019-01-01, 2019-01-10) #> 2     1 [2019-01-12, 2019-01-13) #> 3     2 [2019-01-02, 2019-01-04) #> 4     2 [2019-01-05, 2019-01-07) costs2 <- costs %>%   group_by(user) %>%   mutate(range = iv_identify_group(range))  # `range` has been updated with the corresponding group costs2 #> # A tibble: 6 × 4 #> # Groups:   user [2] #>    user system  cost                    range #>   <int> <chr>  <dbl>               <iv<date>> #> 1     1 a      200.  [2019-01-01, 2019-01-10) #> 2     1 a       15.6 [2019-01-12, 2019-01-13) #> 3     1 b      500.  [2019-01-01, 2019-01-10) #> 4     2 a       25.6 [2019-01-02, 2019-01-04) #> 5     2 c       30   [2019-01-02, 2019-01-04) #> 6     2 c       66.2 [2019-01-05, 2019-01-07)  # So now we can group on that to summarise the cost costs2 %>%   group_by(range, .add = TRUE) %>%   summarise(cost = sum(cost), .groups = \"drop\") #> # A tibble: 4 × 3 #>    user                    range  cost #>   <int>               <iv<date>> <dbl> #> 1     1 [2019-01-01, 2019-01-10) 701.  #> 2     1 [2019-01-12, 2019-01-13)  15.6 #> 3     2 [2019-01-02, 2019-01-04)  55.6 #> 4     2 [2019-01-05, 2019-01-07)  66.2"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"minimal-ivs","dir":"Articles","previous_headings":"Grouping by overlaps","what":"Minimal ivs","title":"Introduction to ivs","text":"iv_groups() critical function package defaults also produce known minimal iv. minimal interval vector: overlapping intervals abutting intervals ordered iv_start(x) iv_end(x) Minimal interval vectors nice cover range interval vector compact form possible. also nice know set operations described set operations section return minimal interval vectors.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"splitting-on-endpoints","dir":"Articles","previous_headings":"","what":"Splitting on endpoints","title":"Introduction to ivs","text":"iv_groups() generates less intervals began , sometimes useful go way generate intervals splitting overlapping endpoints. iv_splits() . operations end generating result contains completely disjoint intervals, go different ways. Let’s look back first iv_groups() example: Notice [9, 11) overlaps [10, 13) turn overlaps [12, 13). looked sorted unique values endpoints (.e. c(9, 10, 11, 12, 13)) paired like [9, 10), [10, 11), [11, 12], [12, 13), nicely split endpoints, generating disjoint set intervals refer “splits”. iv_splits() returns intervals.","code":"x <- iv_pairs(c(1, 5), c(5, 7), c(9, 11), c(10, 13), c(12, 13)) x #> <iv<double>[5]> #> [1] [1, 5)   [5, 7)   [9, 11)  [10, 13) [12, 13) iv_splits(x) #> <iv<double>[6]> #> [1] [1, 5)   [5, 7)   [9, 10)  [10, 11) [11, 12) [12, 13)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"with-group_by-1","dir":"Articles","previous_headings":"Splitting on endpoints","what":"With group_by()","title":"Introduction to ivs","text":"Splitting iv disjoint pieces another operation works nicely group_by(). Consider data set containing details number guests arrived party. ’ve meticulous, ’ve got arrival departure times logged (don’t ask , maybe ’s COVID-19 Contact Tracing purposes). Let’s figure party given point throughout night. , ’ll need break iv possible disjoint intervals mark either arrival departure. Like iv_groups(), iv_splits() can show us disjoint intervals, doesn’t help us map back guest. Instead, ’ll need iv_identify_splits(), identifies splits overlap original intervals returns list results works nicely list-column. little easier understand first look single guest: Since generates list-column, ’ll also immediately use tidyr::unnest() expand . Now splits guest, can group iv summarize figure party point throughout night.","code":"guests <- tibble(   arrive = as.POSIXct(     c(\"2008-05-20 19:30:00\", \"2008-05-20 20:10:00\", \"2008-05-20 22:15:00\"),     tz = \"UTC\"   ),   depart = as.POSIXct(     c(\"2008-05-20 23:00:00\", \"2008-05-21 00:00:00\", \"2008-05-21 00:30:00\"),     tz = \"UTC\"   ),   name = list(     c(\"Mary\", \"Harry\"),     c(\"Diana\", \"Susan\"),     \"Peter\"   ) )  guests <- unnest(guests, name) %>%   mutate(iv = iv(arrive, depart), .keep = \"unused\")  guests #> # A tibble: 5 × 2 #>   name                                          iv #>   <chr>                                 <iv<dttm>> #> 1 Mary  [2008-05-20 19:30:00, 2008-05-20 23:00:00) #> 2 Harry [2008-05-20 19:30:00, 2008-05-20 23:00:00) #> 3 Diana [2008-05-20 20:10:00, 2008-05-21 00:00:00) #> 4 Susan [2008-05-20 20:10:00, 2008-05-21 00:00:00) #> 5 Peter [2008-05-20 22:15:00, 2008-05-21 00:30:00) iv_splits(guests$iv) #> <iv<datetime<UTC>>[5]> #> [1] [2008-05-20 19:30:00, 2008-05-20 20:10:00) #> [2] [2008-05-20 20:10:00, 2008-05-20 22:15:00) #> [3] [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> [4] [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> [5] [2008-05-21 00:00:00, 2008-05-21 00:30:00) # Mary's arrival/departure times guests$iv[[1]] #> <iv<datetime<UTC>>[1]> #> [1] [2008-05-20 19:30:00, 2008-05-20 23:00:00)  # The first start and last end correspond to Mary's original times, # but we've also broken her stay up by the departures/arrivals of # everyone else iv_identify_splits(guests$iv)[[1]] #> <iv<datetime<UTC>>[3]> #> [1] [2008-05-20 19:30:00, 2008-05-20 20:10:00) #> [2] [2008-05-20 20:10:00, 2008-05-20 22:15:00) #> [3] [2008-05-20 22:15:00, 2008-05-20 23:00:00) guests2 <- guests %>%   mutate(iv = iv_identify_splits(iv)) %>%   unnest(iv) %>%   arrange(iv)  guests2 #> # A tibble: 15 × 2 #>    name                                          iv #>    <chr>                                 <iv<dttm>> #>  1 Mary  [2008-05-20 19:30:00, 2008-05-20 20:10:00) #>  2 Harry [2008-05-20 19:30:00, 2008-05-20 20:10:00) #>  3 Mary  [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  4 Harry [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  5 Diana [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  6 Susan [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  7 Mary  [2008-05-20 22:15:00, 2008-05-20 23:00:00) #>  8 Harry [2008-05-20 22:15:00, 2008-05-20 23:00:00) #>  9 Diana [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> 10 Susan [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> 11 Peter [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> 12 Diana [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 13 Susan [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 14 Peter [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 15 Peter [2008-05-21 00:00:00, 2008-05-21 00:30:00) guests2 %>%   group_by(iv) %>%   summarise(n = n(), who = list(name), .groups = \"drop\") #> # A tibble: 5 × 3 #>                                           iv     n who       #>                                   <iv<dttm>> <int> <list>    #> 1 [2008-05-20 19:30:00, 2008-05-20 20:10:00)     2 <chr [2]> #> 2 [2008-05-20 20:10:00, 2008-05-20 22:15:00)     4 <chr [4]> #> 3 [2008-05-20 22:15:00, 2008-05-20 23:00:00)     5 <chr [5]> #> 4 [2008-05-20 23:00:00, 2008-05-21 00:00:00)     3 <chr [3]> #> 5 [2008-05-21 00:00:00, 2008-05-21 00:30:00)     1 <chr [1]>"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"set-operations","dir":"Articles","previous_headings":"","what":"Set operations","title":"Introduction to ivs","text":"number set theoretical operations can use ivs. : iv_set_complement() iv_set_union() iv_set_intersect() iv_set_difference() iv_set_symmetric_difference() iv_set_complement() works single iv, others work two intervals time. functions return minimal interval vector. easiest way think functions imagine iv_groups() called inputs first (reduce minimal form) applying operation. iv_set_complement() computes set complement intervals single iv. default, iv_set_complement() uses smallest/largest values input bounds compute complement , can supply bounds explicitly lower upper: iv_set_union() takes union two ivs. essentially call vctrs::vec_c() followed iv_groups(). answers question, “intervals x y?” iv_set_intersect() takes intersection two ivs. answers question, “intervals x y?” iv_set_difference() takes asymmetrical difference two ivs. answers question, “intervals x y?”","code":"x <- iv_pairs(c(1, 3), c(2, 5), c(10, 12), c(13, 15)) x #> <iv<double>[4]> #> [1] [1, 3)   [2, 5)   [10, 12) [13, 15)  iv_set_complement(x) #> <iv<double>[2]> #> [1] [5, 10)  [12, 13) iv_set_complement(x, lower = 0, upper = Inf) #> <iv<double>[4]> #> [1] [0, 1)    [5, 10)   [12, 13)  [15, Inf) y <- iv_pairs(c(-5, 0), c(1, 4), c(8, 10), c(15, 16))  x #> <iv<double>[4]> #> [1] [1, 3)   [2, 5)   [10, 12) [13, 15) y #> <iv<double>[4]> #> [1] [-5, 0)  [1, 4)   [8, 10)  [15, 16)  iv_set_union(x, y) #> <iv<double>[4]> #> [1] [-5, 0)  [1, 5)   [8, 12)  [13, 16) iv_set_intersect(x, y) #> <iv<double>[1]> #> [1] [1, 4) iv_set_difference(x, y) #> <iv<double>[3]> #> [1] [4, 5)   [10, 12) [13, 15)"},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"pairwise-set-operations","dir":"Articles","previous_headings":"","what":"Pairwise set operations","title":"Introduction to ivs","text":"set operations described treat x y two complete “sets” intervals operate intervals group. Occasionally useful pairwise equivalents operations , say, take intersection -th interval x -th interval y. One case particular comes combining iv_locate_overlaps() iv_pairwise_set_intersect(). might want know two ivs overlaps, also intersection value x. iv_set_intersect() isn’t useful answer particular question, first merges overlapping intervals input. Instead, can find overlaps align , pairwise intersect results: Note pairwise set operations come number restrictions limit usage many cases. example, iv_pairwise_set_intersect() requires x[] y[] overlap, otherwise result empty interval, isn’t allowed. See documentation page iv_pairwise_set_intersect() complete list restrictions pairwise set operations.","code":"starts <- as.Date(c(\"2019-01-05\", \"2019-01-20\", \"2019-01-25\", \"2019-02-01\")) ends <- starts + c(5, 10, 3, 5) x <- iv(starts, ends)  starts <- as.Date(c(\"2019-01-02\", \"2019-01-23\")) ends <- starts + c(5, 6) y <- iv(starts, ends)  x #> <iv<date>[4]> #> [1] [2019-01-05, 2019-01-10) [2019-01-20, 2019-01-30) [2019-01-25, 2019-01-28) #> [4] [2019-02-01, 2019-02-06) y #> <iv<date>[2]> #> [1] [2019-01-02, 2019-01-07) [2019-01-23, 2019-01-29) iv_set_intersect(x, y) #> <iv<date>[2]> #> [1] [2019-01-05, 2019-01-07) [2019-01-23, 2019-01-29) locations <- iv_locate_overlaps(x, y, no_match = \"drop\") overlaps <- iv_align(x, y, locations = locations)  overlaps %>%   mutate(intersect = iv_pairwise_set_intersect(needles, haystack)) #>                    needles                 haystack                intersect #> 1 [2019-01-05, 2019-01-10) [2019-01-02, 2019-01-07) [2019-01-05, 2019-01-07) #> 2 [2019-01-20, 2019-01-30) [2019-01-23, 2019-01-29) [2019-01-23, 2019-01-29) #> 3 [2019-01-25, 2019-01-28) [2019-01-23, 2019-01-29) [2019-01-25, 2019-01-28) iv_pairwise_set_intersect(iv(1, 5), iv(6, 9)) #> Error in `iv_pairwise_set_intersect()`: #> ! Can't take the intersection of non-overlapping intervals. #> ℹ This would result in an empty interval. #> ℹ Location 1 contains non-overlapping intervals."},{"path":"https://davisvaughan.github.io/ivs/dev/articles/ivs.html","id":"missing-intervals","dir":"Articles","previous_headings":"","what":"Missing intervals","title":"Introduction to ivs","text":"Missing intervals allowed ivs, can generate supplying vectors iv() iv_pairs() contain missing values either input. defaults functions ivs treat missing intervals one two ways: Match-like operations treat missing intervals overlapping missing intervals, won’t overlap interval. include iv_locate_overlaps(), iv_set_intersect(), iv_splits(). Pairwise operations treat missing intervals infectious, meaning -th interval x missing -th interval y missing (vice versa), result forced missing interval. include operations prefixed iv_pairwise_*().","code":"x <- iv_pairs(c(1, 5), c(3, NA), c(NA, 3)) x #> <iv<double>[3]> #> [1] [1, 5)   [NA, NA) [NA, NA) y <- iv_pairs(c(NA, NA), c(0, 2)) y #> <iv<double>[2]> #> [1] [NA, NA) [0, 2) # Match-like operations treat missing intervals as overlapping iv_locate_overlaps(x, y) #>   needles haystack #> 1       1        2 #> 2       2        1 #> 3       3        1  iv_set_intersect(x, y) #> <iv<double>[2]> #> [1] [1, 2)   [NA, NA) # Pairwise operations treat missing intervals as infectious z <- iv_pairs(c(1, 2), c(1, 4))  iv_pairwise_set_intersect(y, z) #> <iv<double>[2]> #> [1] [NA, NA) [1, 2)"},{"path":"https://davisvaughan.github.io/ivs/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Vaughan. Author, maintainer. RStudio. Copyright holder, funder.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vaughan D (2023). ivs: Interval Vectors. https://github.com/DavisVaughan/ivs, https://davisvaughan.github.io/ivs/.","code":"@Manual{,   title = {ivs: Interval Vectors},   author = {Davis Vaughan},   year = {2023},   note = {https://github.com/DavisVaughan/ivs, https://davisvaughan.github.io/ivs/}, }"},{"path":"https://davisvaughan.github.io/ivs/dev/index.html","id":"ivs","dir":"","previous_headings":"","what":"Interval Vectors","title":"Interval Vectors","text":"ivs (said, “eye-vees”) package dedicated working intervals generic way. introduces new type, interval vector, generally referred iv. iv created two parallel vectors representing starts (inclusive) ends (exclusive) intervals, like : number useful things can , including: Determining two ivs related (.e. one precede, follow, overlap ?) iv_locate_overlaps(). Grouping / Merging overlapping intervals within single iv iv_groups(). Splitting iv overlapping endpoints iv_splits(). Applying set theoretical operations two ivs, iv_set_intersect(). Interval vectors completely generic, meaning can create comparable type supported vctrs. means user defined S3 types work automatically, like hms::hms(), bit64::integer64(), clock::year_month_day().","code":"library(ivs)  # Interval vector of integers iv(1:5, 7:11) #> <iv<integer>[5]> #> [1] [1, 7)  [2, 8)  [3, 9)  [4, 10) [5, 11)  # Interval vector of dates starts <- as.Date(\"2019-01-01\") + 0:2 ends <- starts + c(2, 5, 10)  iv(starts, ends) #> <iv<date>[3]> #> [1] [2019-01-01, 2019-01-03) [2019-01-02, 2019-01-07) [2019-01-03, 2019-01-13)"},{"path":"https://davisvaughan.github.io/ivs/dev/index.html","id":"learning","dir":"","previous_headings":"","what":"Learning","title":"Interval Vectors","text":"best way learn ivs reading Getting Started vignette!","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Interval Vectors","text":"Install released version CRAN : can install development version ivs GitHub :","code":"install.packages(\"ivs\") # install.packages(\"devtools\") devtools::install_github(\"DavisVaughan/ivs\")"},{"path":"https://davisvaughan.github.io/ivs/dev/index.html","id":"inspiration","dir":"","previous_headings":"","what":"Inspiration","title":"Interval Vectors","text":"package inspired many sources! IRanges closest equivalent, inspired many function names seen . mainly focused integer intervals, always uses closed intervals. also based S4, unfortunately currently means can’t used column tibble current limitations vctrs. intervals another R package supports intervals. supports integer/numeric intervals allows varying endpoint bounds. data.table contains function named foverlaps() detecting overlaps (inspired IRanges::findOverlaps()). Maintaining Knowledge Temporal Intervals paper James Allen iv_locate_relates() based . great primer interval algebra. numbering start 0 small white paper describes right-open intervals often best choice.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count relations from Allen's Interval Algebra — allen-relation-count","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"iv_count_relates() similar iv_count_overlaps(), counts specific set relations developed James Allen paper: Maintaining Knowledge Temporal Intervals.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"","code":"iv_count_relates(   needles,   haystack,   ...,   type,   missing = \"equals\",   no_match = 0L )"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. See Allen's Interval Algebra section complete description type. One : \"precedes\" \"preceded-\" \"meets\" \"met-\" \"overlaps\" \"overlapped-\" \"starts\" \"started-\" \"\" \"contains\" \"finishes\" \"finished-\" \"equals\" missing [integer(1) / \"equals\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . \"error\" throws error intervals needles missing. single integer value provided, represents count returned missing interval needles. Use 0L force missing intervals never match. no_match [integer(1) / \"error\"] Handling needles without match. \"error\" throws error needles zero matches. single integer provided, represents count returned needle zero matches. default value gives unmatched needles count 0L.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"integer vector size needles.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"allen-s-interval-algebra","dir":"Reference","previous_headings":"","what":"Allen's Interval Algebra","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"interval algebra developed James Allen serves basis inspiration iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(). original algebra composed 13 relations following properties: Distinct: pair intervals can related one type. Exhaustive: pairs intervals described one types. Qualitative: numeric intervals considered. relationships computed purely qualitative means. Take notation x y represent two intervals. Now assume x can represented [x_s, x_e), x_s start interval x_e end . Additionally, assume x_s < x_e. notation, 13 relations follows: Precedes: x_e < y_s Preceded-: x_s > y_e Meets: x_e == y_s Met-: x_s == y_e Overlaps: (x_s < y_s) & (x_e > y_s) & (x_e < y_e) Overlapped-: (x_e > y_e) & (x_s < y_e) & (x_s > y_s) Starts: (x_s == y_s) & (x_e < y_e) Started-: (x_s == y_s) & (x_e > y_e) Finishes: (x_s > y_s) & (x_e == y_e) Finished-: (x_s < y_s) & (x_e == y_e) : (x_s > y_s) & (x_e < y_e) Contains: (x_s < y_s) & (x_e > y_e) Equals: (x_s == y_s) & (x_e == y_e) Note missing = \"equals\", missing intervals match type = \"equals\" relation. ensures distinct property algebra maintained.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"connection-to-other-functions","dir":"Reference","previous_headings":"","what":"Connection to other functions","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"Note relations fairly restrictive. example, \"overlaps\" detects cases x straddles y_s. consider case x y equal overlap (\"equals\") consider x straddles y_e overlap (\"overlapped-\"). makes relations extremely useful theoretical perspective, can combined without fear duplicating relations, match typical expectations \"overlap\" . iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows() use intuitive types distinct, typically match expectations better. can expressed terms Allen's relations: iv_locate_overlaps(): \"\": overlaps | overlapped-| starts | started-| finishes | finished-| | contains | equals \"contains\": contains | started-| finished-| equals \"within\": | starts | finishes | equals \"starts\": starts | started-| equals \"ends\": finishes | finished-| equals \"equals\": equals iv_locate_precedes(): precedes | meets iv_locate_follows(): preceded-| met-","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count relations from Allen's Interval Algebra — allen-relation-count","text":"","code":"x <- iv(1, 3) y <- iv(3, 4)  # `\"precedes\"` is strict, and doesn't let the endpoints match iv_count_relates(x, y, type = \"precedes\") #> [1] 0  # Since that is what `\"meets\"` represents iv_count_relates(x, y, type = \"meets\") #> [1] 1  # `\"overlaps\"` is a very specific type of overlap where an interval in # `needles` straddles the start of an interval in `haystack` x <- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5)) y <- iv(1, 4)  # It doesn't match equality, or when the starts match, or when the end # of the interval in `haystack` is straddled instead iv_count_relates(x, y, type = \"overlaps\") #> [1] 0 0 1 0"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"iv_pairwise_relates() similar iv_pairwise_overlaps(), detects specific set relations developed James Allen paper: Maintaining Knowledge Temporal Intervals.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"","code":"iv_pairwise_relates(x, y, ..., type)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"x, y [iv] pair interval vectors. recycled cast type. ... dots future extensions must empty. type [character(1)] type relationship find. See Allen's Interval Algebra section complete description type. One : \"precedes\" \"preceded-\" \"meets\" \"met-\" \"overlaps\" \"overlapped-\" \"starts\" \"started-\" \"\" \"contains\" \"finishes\" \"finished-\" \"equals\"","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"logical vector size common size x y.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"allen-s-interval-algebra","dir":"Reference","previous_headings":"","what":"Allen's Interval Algebra","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"interval algebra developed James Allen serves basis inspiration iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(). original algebra composed 13 relations following properties: Distinct: pair intervals can related one type. Exhaustive: pairs intervals described one types. Qualitative: numeric intervals considered. relationships computed purely qualitative means. Take notation x y represent two intervals. Now assume x can represented [x_s, x_e), x_s start interval x_e end . Additionally, assume x_s < x_e. notation, 13 relations follows: Precedes: x_e < y_s Preceded-: x_s > y_e Meets: x_e == y_s Met-: x_s == y_e Overlaps: (x_s < y_s) & (x_e > y_s) & (x_e < y_e) Overlapped-: (x_e > y_e) & (x_s < y_e) & (x_s > y_s) Starts: (x_s == y_s) & (x_e < y_e) Started-: (x_s == y_s) & (x_e > y_e) Finishes: (x_s > y_s) & (x_e == y_e) Finished-: (x_s < y_s) & (x_e == y_e) : (x_s > y_s) & (x_e < y_e) Contains: (x_s < y_s) & (x_e > y_e) Equals: (x_s == y_s) & (x_e == y_e) Note missing = \"equals\", missing intervals match type = \"equals\" relation. ensures distinct property algebra maintained.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"connection-to-other-functions","dir":"Reference","previous_headings":"","what":"Connection to other functions","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"Note relations fairly restrictive. example, \"overlaps\" detects cases x straddles y_s. consider case x y equal overlap (\"equals\") consider x straddles y_e overlap (\"overlapped-\"). makes relations extremely useful theoretical perspective, can combined without fear duplicating relations, match typical expectations \"overlap\" . iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows() use intuitive types distinct, typically match expectations better. can expressed terms Allen's relations: iv_locate_overlaps(): \"\": overlaps | overlapped-| starts | started-| finishes | finished-| | contains | equals \"contains\": contains | started-| finished-| equals \"within\": | starts | finishes | equals \"starts\": starts | started-| equals \"ends\": finishes | finished-| equals \"equals\": equals iv_locate_precedes(): precedes | meets iv_locate_follows(): preceded-| met-","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect-pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise detect relations from Allen's Interval Algebra — allen-relation-detect-pairwise","text":"","code":"x <- iv_pairs(c(1, 3), c(3, 5)) y <- iv_pairs(c(3, 4), c(6, 7))  # `\"precedes\"` is strict, and doesn't let the endpoints match iv_pairwise_relates(x, y, type = \"precedes\") #> [1] FALSE  TRUE  # Since that is what `\"meets\"` represents iv_pairwise_relates(x, y, type = \"meets\") #> [1]  TRUE FALSE  # `\"during\"` only matches when `x` is completely contained in `y`, and # doesn't allow any endpoints to match x <- iv_pairs(c(1, 3), c(4, 5), c(8, 9)) y <- iv_pairs(c(1, 4), c(3, 8), c(8, 9))  iv_pairwise_relates(x, y, type = \"during\") #> [1] FALSE  TRUE FALSE"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect relations from Allen's Interval Algebra — allen-relation-detect","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"iv_relates() similar iv_overlaps(), detects specific set relations developed James Allen paper: Maintaining Knowledge Temporal Intervals.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"","code":"iv_relates(needles, haystack, ..., type, missing = \"equals\")"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. See Allen's Interval Algebra section complete description type. One : \"precedes\" \"preceded-\" \"meets\" \"met-\" \"overlaps\" \"overlapped-\" \"starts\" \"started-\" \"\" \"contains\" \"finishes\" \"finished-\" \"equals\" missing [logical(1) / \"equals\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . Matched missing intervals needles result TRUE value result, unmatched missing intervals result FALSE value. \"error\" throws error intervals needles missing. single logical value provided, represents value returned result intervals needles missing. can force missing intervals unmatched setting FALSE, can force propagated setting NA.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"logical vector size needles.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"allen-s-interval-algebra","dir":"Reference","previous_headings":"","what":"Allen's Interval Algebra","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"interval algebra developed James Allen serves basis inspiration iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(). original algebra composed 13 relations following properties: Distinct: pair intervals can related one type. Exhaustive: pairs intervals described one types. Qualitative: numeric intervals considered. relationships computed purely qualitative means. Take notation x y represent two intervals. Now assume x can represented [x_s, x_e), x_s start interval x_e end . Additionally, assume x_s < x_e. notation, 13 relations follows: Precedes: x_e < y_s Preceded-: x_s > y_e Meets: x_e == y_s Met-: x_s == y_e Overlaps: (x_s < y_s) & (x_e > y_s) & (x_e < y_e) Overlapped-: (x_e > y_e) & (x_s < y_e) & (x_s > y_s) Starts: (x_s == y_s) & (x_e < y_e) Started-: (x_s == y_s) & (x_e > y_e) Finishes: (x_s > y_s) & (x_e == y_e) Finished-: (x_s < y_s) & (x_e == y_e) : (x_s > y_s) & (x_e < y_e) Contains: (x_s < y_s) & (x_e > y_e) Equals: (x_s == y_s) & (x_e == y_e) Note missing = \"equals\", missing intervals match type = \"equals\" relation. ensures distinct property algebra maintained.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"connection-to-other-functions","dir":"Reference","previous_headings":"","what":"Connection to other functions","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"Note relations fairly restrictive. example, \"overlaps\" detects cases x straddles y_s. consider case x y equal overlap (\"equals\") consider x straddles y_e overlap (\"overlapped-\"). makes relations extremely useful theoretical perspective, can combined without fear duplicating relations, match typical expectations \"overlap\" . iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows() use intuitive types distinct, typically match expectations better. can expressed terms Allen's relations: iv_locate_overlaps(): \"\": overlaps | overlapped-| starts | started-| finishes | finished-| | contains | equals \"contains\": contains | started-| finished-| equals \"within\": | starts | finishes | equals \"starts\": starts | started-| equals \"ends\": finishes | finished-| equals \"equals\": equals iv_locate_precedes(): precedes | meets iv_locate_follows(): preceded-| met-","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect relations from Allen's Interval Algebra — allen-relation-detect","text":"","code":"x <- iv(1, 3) y <- iv(3, 4)  # `\"precedes\"` is strict, and doesn't let the endpoints match iv_relates(x, y, type = \"precedes\") #> [1] FALSE  # Since that is what `\"meets\"` represents iv_relates(x, y, type = \"meets\") #> [1] TRUE  # `\"overlaps\"` is a very specific type of overlap where an interval in # `needles` straddles the start of an interval in `haystack` x <- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5)) y <- iv(1, 4)  # It doesn't match equality, or when the starts match, or when the end # of the interval in `haystack` is straddled instead iv_relates(x, y, type = \"overlaps\") #> [1] FALSE FALSE  TRUE FALSE"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate relations from Allen's Interval Algebra — allen-relation-locate","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"iv_locate_relates() similar iv_locate_overlaps(), locates specific set relations developed James Allen paper: Maintaining Knowledge Temporal Intervals.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"","code":"iv_locate_relates(   needles,   haystack,   ...,   type,   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. See Allen's Interval Algebra section complete description type. One : \"precedes\" \"preceded-\" \"meets\" \"met-\" \"overlaps\" \"overlapped-\" \"starts\" \"started-\" \"\" \"contains\" \"finishes\" \"finished-\" \"equals\" missing [integer(1) / \"equals\" / \"drop\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . \"drop\" drops missing intervals needles result. \"error\" throws error intervals needles missing. single integer provided, represents value returned haystack column intervals needles missing. no_match Handling needles without match. \"drop\" drops needles zero matches result. \"error\" throws error needles zero matches. single integer provided, represents value returned haystack column values needles zero matches. default represents unmatched needle NA. remaining Handling haystack values needles never matched. \"drop\" drops remaining haystack values result. Typically, desired behavior care needles match. \"error\" throws error remaining haystack values. single integer provided (often NA), represents value returned needles column remaining haystack values needles never matched. Remaining haystack values always returned end result. multiple Handling needles multiple matches. needle: \"\" returns matches detected haystack. \"\" returns match detected haystack guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected haystack. \"last\" returns last match detected haystack. relationship Handling expected relationship needles haystack. expectations chosen list invalidated, error thrown. \"none\" perform relationship checks. \"one--one\" expects: value needles matches 1 value haystack. value haystack matches 1 value needles. \"one--many\" expects: value needles matches number values haystack. value haystack matches 1 value needles. \"many--one\" expects: value needles matches 1 value haystack. value haystack matches number values needles. \"many--many\" expects: value needles matches number values haystack. value haystack matches number values needles. performs checks, identical \"none\", provided allow explicit relationship know exists. \"warn-many--many\" assume known relationship, warn needles haystack many--many relationship (typically unexpected), encouraging either take closer look inputs make relationship explicit specifying \"many--many\". relationship applied filter multiple allow potential multiple matches filtered first. relationship handle cases zero matches. , see no_match remaining.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"data frame containing two integer columns named needles haystack.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"allen-s-interval-algebra","dir":"Reference","previous_headings":"","what":"Allen's Interval Algebra","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"interval algebra developed James Allen serves basis inspiration iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(). original algebra composed 13 relations following properties: Distinct: pair intervals can related one type. Exhaustive: pairs intervals described one types. Qualitative: numeric intervals considered. relationships computed purely qualitative means. Take notation x y represent two intervals. Now assume x can represented [x_s, x_e), x_s start interval x_e end . Additionally, assume x_s < x_e. notation, 13 relations follows: Precedes: x_e < y_s Preceded-: x_s > y_e Meets: x_e == y_s Met-: x_s == y_e Overlaps: (x_s < y_s) & (x_e > y_s) & (x_e < y_e) Overlapped-: (x_e > y_e) & (x_s < y_e) & (x_s > y_s) Starts: (x_s == y_s) & (x_e < y_e) Started-: (x_s == y_s) & (x_e > y_e) Finishes: (x_s > y_s) & (x_e == y_e) Finished-: (x_s < y_s) & (x_e == y_e) : (x_s > y_s) & (x_e < y_e) Contains: (x_s < y_s) & (x_e > y_e) Equals: (x_s == y_s) & (x_e == y_e) Note missing = \"equals\", missing intervals match type = \"equals\" relation. ensures distinct property algebra maintained.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"connection-to-other-functions","dir":"Reference","previous_headings":"","what":"Connection to other functions","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"Note relations fairly restrictive. example, \"overlaps\" detects cases x straddles y_s. consider case x y equal overlap (\"equals\") consider x straddles y_e overlap (\"overlapped-\"). makes relations extremely useful theoretical perspective, can combined without fear duplicating relations, match typical expectations \"overlap\" . iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows() use intuitive types distinct, typically match expectations better. can expressed terms Allen's relations: iv_locate_overlaps(): \"\": overlaps | overlapped-| starts | started-| finishes | finished-| | contains | equals \"contains\": contains | started-| finished-| equals \"within\": | starts | finishes | equals \"starts\": starts | started-| equals \"ends\": finishes | finished-| equals \"equals\": equals iv_locate_precedes(): precedes | meets iv_locate_follows(): preceded-| met-","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"Allen, James F. (26 November 1983). \"Maintaining knowledge temporal intervals\". Communications ACM. 26 (11): 832–843.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/allen-relation-locate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate relations from Allen's Interval Algebra — allen-relation-locate","text":"","code":"x <- iv(1, 3) y <- iv(3, 4)  # `\"precedes\"` is strict, and doesn't let the endpoints match iv_locate_relates(x, y, type = \"precedes\") #>   needles haystack #> 1       1       NA  # Since that is what `\"meets\"` represents iv_locate_relates(x, y, type = \"meets\") #>   needles haystack #> 1       1        1  # `\"overlaps\"` is a very specific type of overlap where an interval in # `needles` straddles the start of an interval in `haystack` x <- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5)) y <- iv(1, 4)  # It doesn't match equality, or when the starts match, or when the end # of the interval in `haystack` is straddled instead iv_locate_relates(x, y, type = \"overlaps\") #>   needles haystack #> 1       1       NA #> 2       2       NA #> 3       3        1 #> 4       4       NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/is_iv.html","id":null,"dir":"Reference","previous_headings":"","what":"Is x an iv? — is_iv","title":"Is x an iv? — is_iv","text":"is_iv() tests x iv object.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/is_iv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is x an iv? — is_iv","text":"","code":"is_iv(x)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/is_iv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is x an iv? — is_iv","text":"x [object] object.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/is_iv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is x an iv? — is_iv","text":"single TRUE FALSE.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/is_iv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is x an iv? — is_iv","text":"","code":"is_iv(1) #> [1] FALSE is_iv(new_iv(1, 2)) #> [1] TRUE"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-accessors.html","id":null,"dir":"Reference","previous_headings":"","what":"Access the start or end of an interval vector — iv-accessors","title":"Access the start or end of an interval vector — iv-accessors","text":"iv_start() accesses start interval vector. iv_end() accesses end interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-accessors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access the start or end of an interval vector — iv-accessors","text":"","code":"iv_start(x)  iv_end(x)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-accessors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access the start or end of an interval vector — iv-accessors","text":"x [iv] interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-accessors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access the start or end of an interval vector — iv-accessors","text":"start end x.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-accessors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access the start or end of an interval vector — iv-accessors","text":"","code":"x <- new_iv(1, 2)  iv_start(x) #> [1] 1 iv_end(x) #> [1] 2"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-containers.html","id":null,"dir":"Reference","previous_headings":"","what":"Containers — iv-containers","title":"Containers — iv-containers","text":"family functions revolves around computing interval containers. container defined widest interval contained interval. iv_containers() returns containers found within x. iv_identify_containers() identifies containers interval x falls . replaces x list size element list contains containers corresponding interval x falls . particularly useful alongside tidyr::unnest(). iv_identify_container() similar spirit iv_identify_containers(), useful suspect interval x contained within exactly 1 container. replaces x iv size interval container corresponding interval x falls . interval falls one container, error thrown. iv_locate_containers() returns two column data frame key column containing result iv_containers() loc list-column containing integer vectors map interval x container falls .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-containers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Containers — iv-containers","text":"","code":"iv_containers(x)  iv_identify_containers(x)  iv_identify_container(x)  iv_locate_containers(x)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-containers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Containers — iv-containers","text":"x [iv] interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-containers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Containers — iv-containers","text":"iv_containers(), iv type x. iv_identify_containers(), list-containing ivs size x. iv_identify_container(), iv type x. iv_locate_containers(), two column data frame key column containing result iv_containers() loc list-column containing integer vectors.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-containers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Containers — iv-containers","text":"","code":"library(dplyr, warn.conflicts = FALSE) library(tidyr)  x <- iv_pairs(   c(4, 6),   c(1, 5),   c(2, 3),   c(NA, NA),   c(NA, NA),   c(9, 12),   c(9, 14) ) x #> <iv<double>[7]> #> [1] [4, 6)   [1, 5)   [2, 3)   [NA, NA) [NA, NA) [9, 12)  [9, 14)   # Containers are intervals which aren't contained in any other interval. # They are always returned in ascending order. # If any missing intervals are present, a single one is retained. iv_containers(x) #> <iv<double>[4]> #> [1] [1, 5)   [4, 6)   [9, 14)  [NA, NA)  # `iv_identify_container()` is useful alongside `group_by()` and # `summarize()` if you know that each interval is contained within exactly # 1 container df <- tibble(x = x) df <- mutate(df, container = iv_identify_container(x)) df #> # A tibble: 7 × 2 #>           x container #>   <iv<dbl>> <iv<dbl>> #> 1    [4, 6)    [4, 6) #> 2    [1, 5)    [1, 5) #> 3    [2, 3)    [1, 5) #> 4  [NA, NA)  [NA, NA) #> 5  [NA, NA)  [NA, NA) #> 6   [9, 12)   [9, 14) #> 7   [9, 14)   [9, 14)  df %>%   group_by(container) %>%   summarize(n = n()) #> # A tibble: 4 × 2 #>   container     n #>   <iv<dbl>> <int> #> 1    [1, 5)     2 #> 2    [4, 6)     1 #> 3   [9, 14)     2 #> 4  [NA, NA)     2  # If any interval is contained within multiple containers, # then you can't use `iv_identify_container()` y <- c(x, iv_pairs(c(0, 3), c(8, 13))) y #> <iv<double>[9]> #> [1] [4, 6)   [1, 5)   [2, 3)   [NA, NA) [NA, NA) [9, 12)  [9, 14)  [0, 3)   #> [9] [8, 13)   try(iv_identify_container(y)) #> Error in iv_identify_container(y) :  #>   Intervals in `x` can't fall within multiple containers. #> ℹ Location 3 falls within multiple containers. #> ℹ Use `iv_identify_containers()` to identify all of the containers that a particular interval is contained by.  # Instead, use `iv_identify_containers()` to identify every container # that each interval falls in df <- tibble(y = y, container = iv_identify_containers(y)) df #> # A tibble: 9 × 2 #>           y       container #>   <iv<dbl>> <list<iv<dbl>>> #> 1    [4, 6)             [1] #> 2    [1, 5)             [1] #> 3    [2, 3)             [2] #> 4  [NA, NA)             [1] #> 5  [NA, NA)             [1] #> 6   [9, 12)             [2] #> 7   [9, 14)             [1] #> 8    [0, 3)             [1] #> 9   [8, 13)             [1]  # You can use `tidyr::unchop()` to see the containers that each interval # falls in df %>%   mutate(row = row_number(), .before = 1) %>%   unchop(container) #> # A tibble: 11 × 3 #>      row         y container #>    <int> <iv<dbl>> <iv<dbl>> #>  1     1    [4, 6)    [4, 6) #>  2     2    [1, 5)    [1, 5) #>  3     3    [2, 3)    [0, 3) #>  4     3    [2, 3)    [1, 5) #>  5     4  [NA, NA)  [NA, NA) #>  6     5  [NA, NA)  [NA, NA) #>  7     6   [9, 12)   [8, 13) #>  8     6   [9, 12)   [9, 14) #>  9     7   [9, 14)   [9, 14) #> 10     8    [0, 3)    [0, 3) #> 11     9   [8, 13)   [8, 13)  # A more programmatic interface to `iv_identify_containers()` is # `iv_locate_containers()`, which returns the containers you get from # `iv_containers()` alongside the locations in the input that they contain. iv_locate_containers(y) #>        key  loc #> 1   [0, 3) 3, 8 #> 2   [1, 5) 2, 3 #> 3   [4, 6)    1 #> 4  [8, 13) 6, 9 #> 5  [9, 14) 6, 7 #> 6 [NA, NA) 4, 5"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-genericity.html","id":null,"dir":"Reference","previous_headings":"","what":"Proxy and restore — iv-genericity","title":"Proxy and restore — iv-genericity","text":"iv_proxy() S3 generic allows write S3 methods iv extension types ensure treated like iv objects. input iv extension object, x, return value iv object. iv_restore() S3 generic dispatches allows restore proxied iv extension type back original type. inputs bare iv object, x, original iv extension object, , return value correspond x restored type , possible. typically need create iv_proxy() method class directly extends iv class argument new_iv(). need implement class different structure typical iv object. particular, vctrs::field(x, \"start\") vctrs::field(x, \"end\") return start end interval vector respectively, probably need iv_proxy() method. typically need iv_restore() method custom iv extensions. class simple, can generally just call constructor, like new_my_iv(), restore class additional attributes might required. system allows use iv_*() function iv extension object without define S3 methods . Note default method iv_proxy() returns input unchanged, even iv. iv_*() function separate checking ensure proxy valid iv, implements alternate behavior proxy method implemented. contrast, iv_restore() error method registered.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-genericity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proxy and restore — iv-genericity","text":"","code":"iv_proxy(x, ...)  iv_restore(x, to, ...)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-genericity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proxy and restore — iv-genericity","text":"x [vector] vector. ... dots future extensions must empty. [vector] original vector restore .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-genericity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proxy and restore — iv-genericity","text":"iv_proxy() return iv object manipulation. iv_restore() return object type , possible. cases, may required fall back returning iv object.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-genericity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proxy and restore — iv-genericity","text":"","code":"if (FALSE) { # Registering S3 methods outside of a package doesn't always work quite # right (like on the pkgdown site), so this code should only be run by a # user reading the manual. If that is you, fear not! It should run just fine # in your console.  library(vctrs)  new_nested_iv <- function(iv) {   fields <- list(iv = iv)   new_rcrd(fields, class = \"nested_iv\") }  format.nested_iv <- function(x, ...) {   format(field(x, \"iv\")) }  iv_proxy.nested_iv <- function(x, ...) {   field(x, \"iv\") }  iv_restore.nested_iv <- function(x, to, ...) {   new_nested_iv(x) }  iv <- new_iv(c(1, 5), c(2, 7))  x <- new_nested_iv(iv) x  # Proxies, then accesses the `start` field iv_start(x)  # Proxies, computes the complement to generate an iv, # then restores to the original type iv_set_complement(x)  }"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Group overlapping intervals — iv-groups","title":"Group overlapping intervals — iv-groups","text":"family functions revolves around grouping overlapping intervals within single iv. multiple overlapping intervals grouped together result wider interval containing smallest iv_start() largest iv_end() overlaps. iv_groups() merges overlapping intervals found within x. resulting intervals known \"groups\" x. iv_identify_group() identifies group current interval x falls . particularly useful alongside dplyr::group_by(). iv_locate_groups() returns two column data frame key column containing result iv_groups() loc list-column containing integer vectors map interval x group falls . Optionally, can choose group abutting intervals together abutting = FALSE, can useful like retain boundaries.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"minimal-interval-vectors","dir":"Reference","previous_headings":"","what":"Minimal interval vectors","title":"Group overlapping intervals — iv-groups","text":"iv_groups() particularly useful can generate minimal interval vector, covers range interval vector compact form possible. particular, minimal interval vector: overlapping intervals abutting intervals ordered start end minimal interval vector allowed single missing interval, located end vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group overlapping intervals — iv-groups","text":"","code":"iv_groups(x, ..., abutting = TRUE)  iv_identify_group(x, ..., abutting = TRUE)  iv_locate_groups(x, ..., abutting = TRUE)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group overlapping intervals — iv-groups","text":"x [iv] interval vector. ... dots future extensions must empty. abutting [TRUE / FALSE] abutting intervals grouped together? TRUE, [, b) [b, c) merge [, c). FALSE, kept separate. minimal interval vector, abutting intervals must grouped together.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group overlapping intervals — iv-groups","text":"iv_groups(), iv type x. iv_identify_group(), iv type size x. iv_locate_groups(), two column data frame key column containing result iv_groups() loc list-column containing integer vectors.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"graphical-representation","dir":"Reference","previous_headings":"","what":"Graphical Representation","title":"Group overlapping intervals — iv-groups","text":"Graphically, generating groups looks like:  abutting = FALSE, intervals touch grouped:","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group overlapping intervals — iv-groups","text":"","code":"library(dplyr, warn.conflicts = FALSE)  x <- iv_pairs(   c(1, 5),   c(2, 3),   c(NA, NA),   c(5, 6),   c(NA, NA),   c(9, 12),   c(11, 14) ) x #> <iv<double>[7]> #> [1] [1, 5)   [2, 3)   [NA, NA) [5, 6)   [NA, NA) [9, 12)  [11, 14)  # Grouping removes all redundancy while still covering the full range # of values that were originally represented. If any missing intervals # are present, a single one is retained. iv_groups(x) #> <iv<double>[3]> #> [1] [1, 6)   [9, 14)  [NA, NA)  # Abutting intervals are typically grouped together, but you can choose not # to group them if you want to retain those boundaries iv_groups(x, abutting = FALSE) #> <iv<double>[4]> #> [1] [1, 5)   [5, 6)   [9, 14)  [NA, NA)  # `iv_identify_group()` is useful alongside `group_by()` and `summarize()` df <- tibble(x = x) df <- mutate(df, u = iv_identify_group(x)) df #> # A tibble: 7 × 2 #>           x         u #>   <iv<dbl>> <iv<dbl>> #> 1    [1, 5)    [1, 6) #> 2    [2, 3)    [1, 6) #> 3  [NA, NA)  [NA, NA) #> 4    [5, 6)    [1, 6) #> 5  [NA, NA)  [NA, NA) #> 6   [9, 12)   [9, 14) #> 7  [11, 14)   [9, 14)  df %>%   group_by(u) %>%   summarize(n = n()) #> # A tibble: 3 × 2 #>           u     n #>   <iv<dbl>> <int> #> 1    [1, 6)     3 #> 2   [9, 14)     2 #> 3  [NA, NA)     2  # The real workhorse here is `iv_locate_groups()`, which returns # the groups and information on which observations in `x` fall in which # group iv_locate_groups(x) #>        key     loc #> 1   [1, 6) 1, 2, 4 #> 2  [9, 14)    6, 7 #> 3 [NA, NA)    3, 5"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise set operations — iv-set-pairwise-deprecated","title":"Pairwise set operations — iv-set-pairwise-deprecated","text":"functions deprecated favor set_ prefixed equivalents. iv_pairwise_complement() -> iv_pairwise_set_complement() iv_pairwise_union() -> iv_pairwise_set_union() iv_pairwise_intersect() -> iv_pairwise_set_intersect() iv_pairwise_difference() -> iv_pairwise_set_difference() iv_pairwise_symmetric_difference() -> iv_pairwise_set_symmetric_difference()","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise set operations — iv-set-pairwise-deprecated","text":"","code":"iv_pairwise_complement(x, y)  iv_pairwise_union(x, y)  iv_pairwise_intersect(x, y)  iv_pairwise_difference(x, y)  iv_pairwise_symmetric_difference(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise set operations — iv-set-pairwise-deprecated","text":"x, y [iv] pair interval vectors. cast type, recycled .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise set operations — iv-set-pairwise","title":"Pairwise set operations — iv-set-pairwise","text":"family functions performs pairwise set operations two ivs. Pairwise refers fact -th interval x going compared -th interval y. contrast counterparts, like iv_set_union(), treat entire vector x single set compared y. descriptions operations non-pairwise counterparts, ones also number restrictions due fact must return output size inputs: iv_pairwise_set_complement(), x[] y[] overlap abut, generate empty complement. iv_pairwise_set_union(), x[] y[] separated gap. Use iv_pairwise_span() want force gaps filled anyways. iv_pairwise_set_intersect(), x[] y[] must overlap, otherwise empty interval generated. iv_pairwise_set_difference(), x[] completely contained within y[], generate empty interval. Additionally, y[] completely contained within x[], result two distinct intervals single observation. iv_pairwise_set_symmetric_difference(), x[] y[] must share exactly one endpoint, otherwise empty interval two distinct intervals generated.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise set operations — iv-set-pairwise","text":"","code":"iv_pairwise_set_complement(x, y)  iv_pairwise_set_union(x, y)  iv_pairwise_set_intersect(x, y)  iv_pairwise_set_difference(x, y)  iv_pairwise_set_symmetric_difference(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise set operations — iv-set-pairwise","text":"x, y [iv] pair interval vectors. cast type, recycled .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise set operations — iv-set-pairwise","text":"iv size type x y.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-set-pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise set operations — iv-set-pairwise","text":"","code":"x <- iv_pairs(c(1, 3), c(6, 8)) y <- iv_pairs(c(5, 7), c(2, 3))  iv_pairwise_set_complement(x, y) #> <iv<double>[2]> #> [1] [3, 5) [3, 6)  z <- iv_pairs(c(2, 5), c(4, 7))  iv_pairwise_set_union(x, z) #> <iv<double>[2]> #> [1] [1, 5) [4, 8)  # Can't take the union when there are gaps try(iv_pairwise_set_union(x, y)) #> Error in iv_pairwise_set_union(x, y) :  #>   Can't take the union of intervals containing a gap. #> ℹ Location 1 contains a gap. #> ℹ Use `iv_pairwise_span()` to combine across gaps.  # But you can force a union across gaps with `iv_pairwise_span()` iv_pairwise_span(x, y) #> <iv<double>[2]> #> [1] [1, 7) [2, 8)  iv_pairwise_set_intersect(x, z) #> <iv<double>[2]> #> [1] [2, 3) [6, 7)  # Can't take an intersection of non-overlapping intervals try(iv_pairwise_set_intersect(x, y)) #> Error in iv_pairwise_set_intersect(x, y) :  #>   Can't take the intersection of non-overlapping intervals. #> ℹ This would result in an empty interval. #> ℹ Location 1 contains non-overlapping intervals.  iv_pairwise_set_difference(x, z) #> <iv<double>[2]> #> [1] [1, 2) [7, 8)  # The pairwise symmetric difference function is fairly strict, # and is only well defined when exactly one of the interval endpoints match w <- iv_pairs(c(1, 6), c(7, 8)) iv_pairwise_set_symmetric_difference(x, w) #> <iv<double>[2]> #> [1] [3, 6) [6, 7)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — iv-sets-deprecated","title":"Set operations — iv-sets-deprecated","text":"functions deprecated favor set_ prefixed equivalents. iv_complement() -> iv_set_complement() iv_union() -> iv_set_union() iv_intersect() -> iv_set_intersect() iv_difference() -> iv_set_difference() iv_symmetric_difference() -> iv_set_symmetric_difference()","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — iv-sets-deprecated","text":"","code":"iv_complement(x, ..., lower = NULL, upper = NULL)  iv_union(x, y)  iv_intersect(x, y)  iv_difference(x, y)  iv_symmetric_difference(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — iv-sets-deprecated","text":"x [iv] interval vector. ... dots future extensions must empty. lower, upper [vector(1) / NULL] Bounds universe compute complement. type element type interval vector. often useful expand universe , say, -Inf Inf. y [iv] interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations — iv-sets","title":"Set operations — iv-sets","text":"family functions treats ivs sets. always compute minimal iv input return minimal iv. iv_set_complement() takes complement intervals iv. default, minimum maximum inputs define bounds take complement , can adjusted lower upper. Missing intervals always dropped complement. iv_set_union() answers question, \"intervals x y?\" equivalent combining two vectors together calling iv_groups(). iv_set_intersect() answers question, \"intervals x y?\" iv_set_difference() answers question, \"intervals x y?\" Note asymmetrical difference. iv_set_symmetric_difference() answers question, \"intervals x y ?\"","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations — iv-sets","text":"","code":"iv_set_complement(x, ..., lower = NULL, upper = NULL)  iv_set_union(x, y)  iv_set_intersect(x, y)  iv_set_difference(x, y)  iv_set_symmetric_difference(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations — iv-sets","text":"x [iv] interval vector. ... dots future extensions must empty. lower, upper [vector(1) / NULL] Bounds universe compute complement. type element type interval vector. often useful expand universe , say, -Inf Inf. y [iv] interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations — iv-sets","text":"iv_set_complement(), vector type x containing complement. set operations, vector type common type x y containing result.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":"graphical-representation","dir":"Reference","previous_headings":"","what":"Graphical Representation","title":"Set operations — iv-sets","text":"Graphically, generating complement looks like:  set upper = 20 intervals, get one interval complement.  Generating intersection two ivs looks like:","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-sets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations — iv-sets","text":"","code":"x <- iv_pairs(   c(10, 12),   c(0, 5),   c(NA, NA),   c(3, 6),   c(-5, -2),   c(NA, NA) ) x #> <iv<double>[6]> #> [1] [10, 12) [0, 5)   [NA, NA) [3, 6)   [-5, -2) [NA, NA)  y <- iv_pairs(   c(2, 7),   c(NA, NA),   c(-3, -1),   c(14, 15) ) y #> <iv<double>[4]> #> [1] [2, 7)   [NA, NA) [-3, -1) [14, 15)  # Complement contains any values from `[-5, 12)` that aren't represented # in these intervals. Missing intervals are dropped. iv_set_complement(x) #> <iv<double>[2]> #> [1] [-2, 0) [6, 10)  # Expand out the \"universe\" of possible values iv_set_complement(x, lower = -Inf) #> <iv<double>[3]> #> [1] [-Inf, -5) [-2, 0)    [6, 10)    iv_set_complement(x, lower = -Inf, upper = Inf) #> <iv<double>[4]> #> [1] [-Inf, -5) [-2, 0)    [6, 10)    [12, Inf)   # Which intervals are in x or y? iv_set_union(x, y) #> <iv<double>[5]> #> [1] [-5, -1) [0, 7)   [10, 12) [14, 15) [NA, NA)  # Which intervals are in x and y? iv_set_intersect(x, y) #> <iv<double>[3]> #> [1] [-3, -2) [2, 6)   [NA, NA)  # Which intervals are in x but not y? iv_set_difference(x, y) #> <iv<double>[3]> #> [1] [-5, -3) [0, 2)   [10, 12)  # Which intervals are in y but not x? iv_set_difference(y, x) #> <iv<double>[3]> #> [1] [-2, -1) [6, 7)   [14, 15)  # Missing intervals in x are kept if there aren't missing intervals in y iv_set_difference(x, iv(1, 2)) #> <iv<double>[5]> #> [1] [-5, -2) [0, 1)   [2, 6)   [10, 12) [NA, NA)  # Which intervals are in x or y but not both? iv_set_symmetric_difference(x, y) #> <iv<double>[6]> #> [1] [-5, -3) [-2, -1) [0, 2)   [6, 7)   [10, 12) [14, 15)  # Missing intervals will be kept if they only appear on one side iv_set_symmetric_difference(x, iv(1, 2)) #> <iv<double>[5]> #> [1] [-5, -2) [0, 1)   [2, 6)   [10, 12) [NA, NA) iv_set_symmetric_difference(iv(1, 2), x) #> <iv<double>[5]> #> [1] [-5, -2) [0, 1)   [2, 6)   [10, 12) [NA, NA)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Splits — iv-splits","title":"Splits — iv-splits","text":"family functions revolves around splitting iv endpoints, results new iv entirely disjoint (.e. non-overlapping). intervals resulting iv known \"splits\". iv_splits() computes disjoint splits x. iv_identify_splits() identifies splits correspond interval x. replaces x list size element list contains splits corresponding interval x overlaps. particularly useful alongside tidyr::unnest(). iv_locate_splits() returns two column data frame key column containing result iv_splits() loc list-column containing integer vectors map interval x splits overlaps.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splits — iv-splits","text":"","code":"iv_splits(x, ..., on = NULL)  iv_identify_splits(x, ..., on = NULL)  iv_locate_splits(x, ..., on = NULL)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splits — iv-splits","text":"x [iv] interval vector. ... dots future extensions must empty. [vector / NULL] optional vector additional values split . type iv_start(x).","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splits — iv-splits","text":"iv_splits(), iv type x. iv_identify_splits(), list-containing ivs size x. iv_locate_splits(), two column data frame key column type x loc list-column containing integer vectors.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":"graphical-representation","dir":"Reference","previous_headings":"","what":"Graphical Representation","title":"Splits — iv-splits","text":"Graphically, generating splits looks like:","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv-splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splits — iv-splits","text":"","code":"library(tidyr) library(dplyr)  # Guests to a party and their arrival/departure times guests <- tibble(   arrive = as.POSIXct(     c(\"2008-05-20 19:30:00\", \"2008-05-20 20:10:00\", \"2008-05-20 22:15:00\"),     tz = \"UTC\"   ),   depart = as.POSIXct(     c(\"2008-05-20 23:00:00\", \"2008-05-21 00:00:00\", \"2008-05-21 00:30:00\"),     tz = \"UTC\"   ),   name = list(     c(\"Mary\", \"Harry\"),     c(\"Diana\", \"Susan\"),     \"Peter\"   ) )  guests <- unnest(guests, name) %>%   mutate(iv = iv(arrive, depart), .keep = \"unused\")  guests #> # A tibble: 5 × 2 #>   name                                          iv #>   <chr>                                 <iv<dttm>> #> 1 Mary  [2008-05-20 19:30:00, 2008-05-20 23:00:00) #> 2 Harry [2008-05-20 19:30:00, 2008-05-20 23:00:00) #> 3 Diana [2008-05-20 20:10:00, 2008-05-21 00:00:00) #> 4 Susan [2008-05-20 20:10:00, 2008-05-21 00:00:00) #> 5 Peter [2008-05-20 22:15:00, 2008-05-21 00:30:00)  # You can determine the disjoint intervals at which people # arrived/departed with `iv_splits()` iv_splits(guests$iv) #> <iv<datetime<UTC>>[5]> #> [1] [2008-05-20 19:30:00, 2008-05-20 20:10:00) #> [2] [2008-05-20 20:10:00, 2008-05-20 22:15:00) #> [3] [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> [4] [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> [5] [2008-05-21 00:00:00, 2008-05-21 00:30:00)  # Say you'd like to determine who was at the party at any given time # throughout the night guests <- mutate(guests, splits = iv_identify_splits(iv)) guests #> # A tibble: 5 × 3 #>   name                                          iv           splits #>   <chr>                                 <iv<dttm>> <list<iv<dttm>>> #> 1 Mary  [2008-05-20 19:30:00, 2008-05-20 23:00:00)              [3] #> 2 Harry [2008-05-20 19:30:00, 2008-05-20 23:00:00)              [3] #> 3 Diana [2008-05-20 20:10:00, 2008-05-21 00:00:00)              [3] #> 4 Susan [2008-05-20 20:10:00, 2008-05-21 00:00:00)              [3] #> 5 Peter [2008-05-20 22:15:00, 2008-05-21 00:30:00)              [3]  # Unnest the splits to generate disjoint intervals for each guest guests <- guests %>%   unnest(splits) %>%   select(name, splits)  guests #> # A tibble: 15 × 2 #>    name                                      splits #>    <chr>                                 <iv<dttm>> #>  1 Mary  [2008-05-20 19:30:00, 2008-05-20 20:10:00) #>  2 Mary  [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  3 Mary  [2008-05-20 22:15:00, 2008-05-20 23:00:00) #>  4 Harry [2008-05-20 19:30:00, 2008-05-20 20:10:00) #>  5 Harry [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  6 Harry [2008-05-20 22:15:00, 2008-05-20 23:00:00) #>  7 Diana [2008-05-20 20:10:00, 2008-05-20 22:15:00) #>  8 Diana [2008-05-20 22:15:00, 2008-05-20 23:00:00) #>  9 Diana [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 10 Susan [2008-05-20 20:10:00, 2008-05-20 22:15:00) #> 11 Susan [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> 12 Susan [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 13 Peter [2008-05-20 22:15:00, 2008-05-20 23:00:00) #> 14 Peter [2008-05-20 23:00:00, 2008-05-21 00:00:00) #> 15 Peter [2008-05-21 00:00:00, 2008-05-21 00:30:00)  # Tabulate who was there at any given time guests %>%   group_by(splits) %>%   summarise(n = n(), who = list(name)) #> # A tibble: 5 × 3 #>                                       splits     n who       #>                                   <iv<dttm>> <int> <list>    #> 1 [2008-05-20 19:30:00, 2008-05-20 20:10:00)     2 <chr [2]> #> 2 [2008-05-20 20:10:00, 2008-05-20 22:15:00)     4 <chr [4]> #> 3 [2008-05-20 22:15:00, 2008-05-20 23:00:00)     5 <chr [5]> #> 4 [2008-05-20 23:00:00, 2008-05-21 00:00:00)     3 <chr [3]> #> 5 [2008-05-21 00:00:00, 2008-05-21 00:30:00)     1 <chr [1]>  # ---------------------------------------------------------------------------  x <- iv_pairs(c(1, 5), c(4, 9), c(12, 15)) x #> <iv<double>[3]> #> [1] [1, 5)   [4, 9)   [12, 15)  # You can provide additional singular values to split on with `on` iv_splits(x, on = c(2, 13)) #> <iv<double>[6]> #> [1] [1, 2)   [2, 4)   [4, 5)   [5, 9)   [12, 13) [13, 15)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an interval vector — iv","title":"Create an interval vector — iv","text":"iv() creates interval vector start end vectors. typically create interval vectors, often used columns data frame. iv_pairs() creates interval vector pairs. often useful interactive testing, provides intuitive interface creating small interval vectors. generally used large scale can slow.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"intervals","dir":"Reference","previous_headings":"","what":"Intervals","title":"Create an interval vector — iv","text":"Interval vectors right-open, .e. [start, end). means start < end requirement generate interval vector. particular, empty intervals start == end allowed. Right-open intervals tend practically useful. example, [2019-01-01 00:00:00, 2019-01-02 00:00:00) nicely encapsulates times 2019-01-01. closed intervals, attempt specify 2019-01-01 23:59:59, inconvenient inaccurate, capture fractional seconds. Right-open intervals also extremely nice technical property create closed algebra. Concretely, complement vector right-open intervals union, intersection, difference two vectors right-open intervals always result another vector right-open intervals.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"missing-intervals","dir":"Reference","previous_headings":"","what":"Missing intervals","title":"Create an interval vector — iv","text":"creating interval vectors iv(), either bound incomplete, bounds set missing value.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an interval vector — iv","text":"","code":"iv(start, end, ..., ptype = NULL, size = NULL)  iv_pairs(..., ptype = NULL)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an interval vector — iv","text":"start, end [vector] pair vectors represent bounds intervals. valid interval vector, start must strictly less end. either start end incomplete / missing, bounds coerced missing values. start end recycled cast type. ... iv_pairs(): [vector pairs] Vectors size 2 representing intervals include result. inputs cast type. iv(): dots future extensions must empty. ptype [vector(0) / NULL] prototype force inner type resulting iv. NULL, defaults common type inputs. size [integer(1) / NULL] size force resulting iv. NULL, defaults common size inputs.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an interval vector — iv","text":"iv.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an interval vector — iv","text":"","code":"library(dplyr, warn.conflicts = FALSE)  set.seed(123)  x <- tibble(   start = as.Date(\"2019-01-01\") + 1:5,   end = start + sample(1:10, length(start), replace = TRUE) )  # Typically you'll use `iv()` with columns of a data frame mutate(x, iv = iv(start, end), .keep = \"unused\") #> # A tibble: 5 × 1 #>                         iv #>                 <iv<date>> #> 1 [2019-01-02, 2019-01-05) #> 2 [2019-01-03, 2019-01-06) #> 3 [2019-01-04, 2019-01-14) #> 4 [2019-01-05, 2019-01-07) #> 5 [2019-01-06, 2019-01-12)  # `iv_pairs()` is useful for generating interval vectors interactively iv_pairs(c(1, 5), c(2, 3), c(6, 10)) #> <iv<double>[3]> #> [1] [1, 5)  [2, 3)  [6, 10)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_align.html","id":null,"dir":"Reference","previous_headings":"","what":"Align after locating relationships — iv_align","title":"Align after locating relationships — iv_align","text":"iv_align() align/join needles haystack together using data frame locations. locations intended output one : iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(), iv_locate_relates(), iv_locate_between(). mainly convenience function slices needles haystack according locations, stores result new two column data frame.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align after locating relationships — iv_align","text":"","code":"iv_align(needles, haystack, ..., locations)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_align.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align after locating relationships — iv_align","text":"needles, haystack [vector] Two vectors align. ... dots future extensions must empty. locations [two-column data frame] data frame locations returned one iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(), iv_locate_relates(), iv_locate_between().","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_align.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align after locating relationships — iv_align","text":"two column data frame $needles column containing sliced version needles $haystack column containing sliced version haystack.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_align.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align after locating relationships — iv_align","text":"","code":"needles <- iv_pairs(c(1, 5), c(3, 7), c(10, 12)) haystack <- iv_pairs(c(0, 2), c(4, 6))  locations <- iv_locate_overlaps(needles, haystack) iv_align(needles, haystack, locations = locations) #>    needles haystack #> 1   [1, 5)   [0, 2) #> 2   [1, 5)   [4, 6) #> 3   [3, 7)   [4, 6) #> 4 [10, 12) [NA, NA)  locations <- iv_locate_overlaps(needles, haystack, no_match = \"drop\") iv_align(needles, haystack, locations = locations) #>   needles haystack #> 1  [1, 5)   [0, 2) #> 2  [1, 5)   [4, 6) #> 3  [3, 7)   [4, 6)  needles <- c(1, 15, 4, 11) haystack <- iv_pairs(c(1, 5), c(3, 7), c(10, 12))  locations <- iv_locate_between(needles, haystack) iv_align(needles, haystack, locations = locations) #>   needles haystack #> 1       1   [1, 5) #> 2      15 [NA, NA) #> 3       4   [1, 5) #> 4       4   [3, 7) #> 5      11 [10, 12)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Diff a vector to create an interval vector — iv_diff","title":"Diff a vector to create an interval vector — iv_diff","text":"iv_diff() convenient way generate iv preexisting vector, long vector strictly increasing order. returns iv 1 element shorter x (unless x already empty). particularly useful creating iv column existing column inside dplyr::mutate(), requires explicitly handle padding case, see examples. Missing values allowed, propagated side resulting interval applying diff.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diff a vector to create an interval vector — iv_diff","text":"","code":"iv_diff(x)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diff a vector to create an interval vector — iv_diff","text":"x [vector] vector strictly increasing order.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diff a vector to create an interval vector — iv_diff","text":"iv using x inner type, size equal max(0L, vec_size(x) - 1L).","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diff a vector to create an interval vector — iv_diff","text":"iv_diff() inspired diff().","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diff a vector to create an interval vector — iv_diff","text":"","code":"x <- as.Date(\"2019-01-01\") + c(0, 5, 7, 10, 19) x #> [1] \"2019-01-01\" \"2019-01-06\" \"2019-01-08\" \"2019-01-11\" \"2019-01-20\"  # Notice how the boundaries don't overlap, because the closing `)` aligns # with an opening `[`. iv_diff(x) #> <iv<date>[4]> #> [1] [2019-01-01, 2019-01-06) [2019-01-06, 2019-01-08) [2019-01-08, 2019-01-11) #> [4] [2019-01-11, 2019-01-20)  # Like `iv()`, missing values propagate to both boundaries of the interval. # Before missing value propagation was applied, it looked like this: # [1, NA), [NA, 2), [2, 3) x <- c(1, NA, 2, 3) iv_diff(x) #> <iv<double>[3]> #> [1] [NA, NA) [NA, NA) [2, 3)    # Values in `x` must be in strictly increasing order to generate a valid # interval vector x <- c(1, 0, 2, 2) try(iv_diff(x)) #> Error in iv_diff(x) : `x` must be in strictly increasing order. #> ℹ `x` is not in strictly increasing order at locations: `c(2, 4)`.  x <- c(1, NA, 0) try(iv_diff(x)) #> Error in iv_diff(x) : `x` must be in strictly increasing order. #> ℹ `x` is not in strictly increasing order at locations: `3`.  # --------------------------------------------------------------------------- # Use with `mutate()`  library(dplyr)  # `iv_diff()` is useful for converting a pre-existing column into an interval # vector, but you'll need to apply padding to ensure that the size of the # diff-ed result is the same as the number of rows in your data frame. There # are two main ways to pad, which are explored below. df <- tibble(x = c(1, 3, 6))  # Pad with a known lower/upper bound df %>% mutate(iv = iv_diff(c(0, x))) #> # A tibble: 3 × 2 #>       x        iv #>   <dbl> <iv<dbl>> #> 1     1    [0, 1) #> 2     3    [1, 3) #> 3     6    [3, 6) df %>% mutate(iv = iv_diff(c(x, Inf))) #> # A tibble: 3 × 2 #>       x        iv #>   <dbl> <iv<dbl>> #> 1     1    [1, 3) #> 2     3    [3, 6) #> 3     6  [6, Inf)  # Pad with a missing value, which results in a fully missing interval df %>% mutate(iv = iv_diff(c(NA, x))) #> # A tibble: 3 × 2 #>       x        iv #>   <dbl> <iv<dbl>> #> 1     1  [NA, NA) #> 2     3    [1, 3) #> 3     6    [3, 6) df %>% mutate(iv = iv_diff(c(x, NA))) #> # A tibble: 3 × 2 #>       x        iv #>   <dbl> <iv<dbl>> #> 1     1    [1, 3) #> 2     3    [3, 6) #> 3     6  [NA, NA)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting — iv_format","title":"Formatting — iv_format","text":"iv_format() S3 generic intended developer tool making custom class print nicely stored iv. default method simply calls format(), many cases enough classes. However, class automatically adds justification padding formatting single vector, might need implement iv_format() method avoid padding, since often looks strange nested interval vector.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formatting — iv_format","text":"","code":"iv_format(x)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formatting — iv_format","text":"x [vector] vector format. called iv_start() iv_end() vectors iv.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formatting — iv_format","text":"character vector, likely generated call format().","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formatting — iv_format","text":"","code":"# Numeric values get padding automatically through `format()` x <- c(1, 100) format(x) #> [1] \"  1\" \"100\"  # This ends up looking strange in an iv, so an `iv_format()` method for # numeric values is implemented which turns off that padding iv_format(x) #> [1] \"1\"   \"100\""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_pairwise_span.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise span — iv_pairwise_span","title":"Pairwise span — iv_pairwise_span","text":"iv_pairwise_span() computes pairwise \"span\" -th interval x -th interval y. pairwise span two intervals new interval containing minimum start maximum end original intervals. similar iv_pairwise_set_union(), except fills across gaps.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_pairwise_span.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise span — iv_pairwise_span","text":"","code":"iv_pairwise_span(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_pairwise_span.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise span — iv_pairwise_span","text":"x, y [iv] pair interval vectors. cast type, recycled .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_pairwise_span.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise span — iv_pairwise_span","text":"iv size type x y.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/iv_pairwise_span.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise span — iv_pairwise_span","text":"","code":"x <- iv_pairs(c(1, 3), c(6, 8)) y <- iv_pairs(c(5, 7), c(2, 3))  # Can't take the set union when there are gaps try(iv_pairwise_set_union(x, y)) #> Error in iv_pairwise_set_union(x, y) :  #>   Can't take the union of intervals containing a gap. #> ℹ Location 1 contains a gap. #> ℹ Use `iv_pairwise_span()` to combine across gaps.  # But you can compute the span of the intervals iv_pairwise_span(x, y) #> <iv<double>[2]> #> [1] [1, 7) [2, 8)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/ivs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"ivs: Interval Vectors — ivs-package","title":"ivs: Interval Vectors — ivs-package","text":"Provides library generic interval manipulations using new interval vector class. Capabilities include: locating various kinds relationships two interval vectors, merging overlaps within single interval vector, splitting interval vector overlapping endpoints, applying set theoretical operations interval vectors. Many operations package inspired James Allen's interval algebra, Allen (1983) doi:10.1145/182.358434 .","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/ivs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ivs: Interval Vectors — ivs-package","text":"Maintainer: Davis Vaughan davis@rstudio.com contributors: RStudio [copyright holder, funder]","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/new_iv.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a new iv — new_iv","title":"Construct a new iv — new_iv","text":"new_iv() developer focused function creating new interval vector. minimal checks inputs, performance.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/new_iv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a new iv — new_iv","text":"","code":"new_iv(start, end, ..., class = character())"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/new_iv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a new iv — new_iv","text":"start, end [vector] pair vectors represent bounds intervals. valid interval vector, start must strictly less end, start end must missing value. ... [name-value pairs] Additional named attributes attach result. class [character] name subclass create.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/new_iv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a new iv — new_iv","text":"new iv object.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/new_iv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a new iv — new_iv","text":"","code":"new_iv(1, 2) #> <iv<double>[1]> #> [1] [1, 2)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count relationships between two ivs — relation-count","title":"Count relationships between two ivs — relation-count","text":"family functions counts different types relationships two ivs. works similar base::match(), needles[] checks relationship haystack. iv_count_overlaps() counts instances specific type overlap two ivs. iv_count_precedes() counts instances needles[] precedes (.e. comes ) interval haystack. iv_count_follows() counts instances needles[] follows (.e. comes ) interval haystack. functions return integer vector size needles containing count times particular relationship -th interval needles interval haystack occurred.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count relationships between two ivs — relation-count","text":"","code":"iv_count_overlaps(   needles,   haystack,   ...,   type = \"any\",   missing = \"equals\",   no_match = 0L )  iv_count_precedes(   needles,   haystack,   ...,   closest = FALSE,   missing = \"equals\",   no_match = 0L )  iv_count_follows(   needles,   haystack,   ...,   closest = FALSE,   missing = \"equals\",   no_match = 0L )"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count relationships between two ivs — relation-count","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. One : \"\": Finds overlap whatsoever interval needles interval haystack. \"within\": Finds interval needles completely within (equal ) interval haystack. \"contains\": Finds interval needles completely contains (equals) interval haystack. \"equals\": Finds interval needles exactly equal interval haystack. \"starts\": Finds start interval needles matches start interval haystack. \"ends\": Finds end interval needles matches end interval haystack. missing [integer(1) / \"equals\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . \"error\" throws error intervals needles missing. single integer value provided, represents count returned missing interval needles. Use 0L force missing intervals never match. no_match [integer(1) / \"error\"] Handling needles without match. \"error\" throws error needles zero matches. single integer provided, represents count returned needle zero matches. default value gives unmatched needles count 0L. closest [TRUE / FALSE] closest relationship returned? TRUE, return closest interval(s) haystack current value needles either precedes follows. Note multiple intervals can still returned ties, can resolved using multiple.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count relationships between two ivs — relation-count","text":"integer vector size needles.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count relationships between two ivs — relation-count","text":"","code":"library(vctrs) #>  #> Attaching package: ‘vctrs’ #> The following object is masked from ‘package:dplyr’: #>  #>     data_frame  x <- iv_pairs(   as.Date(c(\"2019-01-05\", \"2019-01-10\")),   as.Date(c(\"2019-01-07\", \"2019-01-15\")),   as.Date(c(\"2019-01-20\", \"2019-01-31\")) )  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> <iv<date>[3]> #> [1] [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-15) [2019-01-20, 2019-01-31) y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Count the number of times `x` overlaps `y` at all iv_count_overlaps(x, y) #> [1] 2 3 0  # Count the number of times `y` is within an interval in `x` iv_count_overlaps(y, x, type = \"within\") #> [1] 0 0 2 0 0  # Count the number of times `x` precedes `y` iv_count_precedes(x, y) #> [1] 2 1 0  # ---------------------------------------------------------------------------  a <- iv(c(1, NA), c(2, NA)) b <- iv(c(NA, NA), c(NA, NA))  # Missing intervals are seen as exactly equal by default, so they are # considered to overlap iv_count_overlaps(a, b) #> [1] 0 2  # If you'd like missing intervals to be treated as unmatched, set # `missing = 0L` iv_count_overlaps(a, b, missing = 0L) #> [1] 0 0  # If you'd like to propagate missing intervals, set `missing = NA` iv_count_overlaps(a, b, missing = NA) #> [1]  0 NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect-pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","title":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","text":"family functions detects different types relationships two ivs pairwise, pairwise means -th interval x compared -th interval y. contrast iv_overlaps(), works like base::%%. iv_pairwise_overlaps() detects specific type overlap -th interval x -th interval y. iv_pairwise_precedes() detects -th interval x precedes (.e. comes ) -th interval y. iv_pairwise_follows() detects -th interval x follows (.e. comes ) -th interval y. functions return logical vector size common size x y.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect-pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","text":"","code":"iv_pairwise_overlaps(x, y, ..., type = \"any\")  iv_pairwise_precedes(x, y)  iv_pairwise_follows(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect-pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","text":"x, y [iv] pair interval vectors. recycled cast type. ... dots future extensions must empty. type [character(1)] type relationship find. One : \"\": Finds overlap whatsoever interval needles interval haystack. \"within\": Finds interval needles completely within (equal ) interval haystack. \"contains\": Finds interval needles completely contains (equals) interval haystack. \"equals\": Finds interval needles exactly equal interval haystack. \"starts\": Finds start interval needles matches start interval haystack. \"ends\": Finds end interval needles matches end interval haystack.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect-pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","text":"logical vector size common size x y.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect-pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise detect a relationship between two ivs — relation-detect-pairwise","text":"","code":"library(vctrs)  x <- iv_pairs(   as.Date(c(\"2019-01-05\", \"2019-01-10\")),   as.Date(c(\"2019-01-07\", \"2019-01-15\")),   as.Date(c(\"2019-01-20\", \"2019-01-31\")) )  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-18\", \"2019-01-21\")) )  x #> <iv<date>[3]> #> [1] [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-15) [2019-01-20, 2019-01-31) y #> <iv<date>[3]> #> [1] [2019-01-01, 2019-01-03) [2019-01-07, 2019-01-09) [2019-01-18, 2019-01-21)  # Does the i-th interval of `x` overlap the i-th interval of `y`? iv_pairwise_overlaps(x, y) #> [1] FALSE  TRUE  TRUE  # Does the i-th interval of `x` contain the i-th interval of `y`? iv_pairwise_overlaps(x, y, type = \"contains\") #> [1] FALSE  TRUE FALSE  # Does the i-th interval of `x` follow the i-th interval of `y`? iv_pairwise_follows(x, y) #> [1]  TRUE FALSE FALSE  a <- iv_pairs(c(1, 2), c(NA, NA), c(NA, NA)) b <- iv_pairs(c(NA, NA), c(3, 4), c(NA, NA))  # Missing intervals always propagate iv_pairwise_overlaps(a, b) #> [1] NA NA NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect a relationship between two ivs — relation-detect","title":"Detect a relationship between two ivs — relation-detect","text":"family functions detects different types relationships two ivs. works similar base::%%, needles[] checks relationship haystack. iv_overlaps() detects specific type overlap two ivs. iv_precedes() detects needles[] precedes (.e. comes ) interval haystack. iv_follows() detects needles[] follows (.e. comes ) interval haystack. functions return logical vector size needles containing TRUE interval needles matching relationship haystack FALSE otherwise.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect a relationship between two ivs — relation-detect","text":"","code":"iv_overlaps(needles, haystack, ..., type = \"any\", missing = \"equals\")  iv_precedes(needles, haystack, ..., missing = \"equals\")  iv_follows(needles, haystack, ..., missing = \"equals\")"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect a relationship between two ivs — relation-detect","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. One : \"\": Finds overlap whatsoever interval needles interval haystack. \"within\": Finds interval needles completely within (equal ) interval haystack. \"contains\": Finds interval needles completely contains (equals) interval haystack. \"equals\": Finds interval needles exactly equal interval haystack. \"starts\": Finds start interval needles matches start interval haystack. \"ends\": Finds end interval needles matches end interval haystack. missing [logical(1) / \"equals\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . Matched missing intervals needles result TRUE value result, unmatched missing intervals result FALSE value. \"error\" throws error intervals needles missing. single logical value provided, represents value returned result intervals needles missing. can force missing intervals unmatched setting FALSE, can force propagated setting NA.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect a relationship between two ivs — relation-detect","text":"logical vector size needles.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect a relationship between two ivs — relation-detect","text":"","code":"library(vctrs)  x <- iv_pairs(   as.Date(c(\"2019-01-05\", \"2019-01-10\")),   as.Date(c(\"2019-01-07\", \"2019-01-15\")),   as.Date(c(\"2019-01-20\", \"2019-01-31\")) )  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> <iv<date>[3]> #> [1] [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-15) [2019-01-20, 2019-01-31) y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Does each interval of `x` overlap `y` at all? iv_overlaps(x, y) #> [1]  TRUE  TRUE FALSE  # Which intervals of `y` are within an interval in `x`? iv_overlaps(y, x, type = \"within\") #> [1] FALSE FALSE  TRUE FALSE FALSE  # ---------------------------------------------------------------------------  a <- iv(c(1, NA), c(2, NA)) b <- iv(c(NA, NA), c(NA, NA))  # Missing intervals are seen as exactly equal by default, so they are # considered to overlap iv_overlaps(a, b) #> [1] FALSE  TRUE  # If you'd like missing intervals to be treated as unmatched, set # `missing = FALSE` iv_overlaps(a, b, missing = FALSE) #> [1] FALSE FALSE  # If you'd like to propagate missing intervals, set `missing = NA` iv_overlaps(a, b, missing = NA) #> [1] FALSE    NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-locate.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate relationships between two ivs — relation-locate","title":"Locate relationships between two ivs — relation-locate","text":"family functions locates different types relationships two ivs. works similar base::match(), needles[] checks relationship haystack. Unlike match(), matching relationships returned, rather just first. iv_locate_overlaps() locates specific type overlap two ivs. iv_locate_precedes() locates needles[] precedes (.e. comes ) interval haystack. iv_locate_follows() locates needles[] follows (.e. comes ) interval haystack. functions return two column data frame. needles column integer vector pointing locations needles. haystack column integer vector pointing locations haystack matching relationship.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-locate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate relationships between two ivs — relation-locate","text":"","code":"iv_locate_overlaps(   needles,   haystack,   ...,   type = \"any\",   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )  iv_locate_precedes(   needles,   haystack,   ...,   closest = FALSE,   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )  iv_locate_follows(   needles,   haystack,   ...,   closest = FALSE,   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-locate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate relationships between two ivs — relation-locate","text":"needles, haystack [iv] Interval vectors used relation matching. element needles represents interval search . haystack represents intervals search . Prior comparison, needles haystack coerced type. ... dots future extensions must empty. type [character(1)] type relationship find. One : \"\": Finds overlap whatsoever interval needles interval haystack. \"within\": Finds interval needles completely within (equal ) interval haystack. \"contains\": Finds interval needles completely contains (equals) interval haystack. \"equals\": Finds interval needles exactly equal interval haystack. \"starts\": Finds start interval needles matches start interval haystack. \"ends\": Finds end interval needles matches end interval haystack. missing [integer(1) / \"equals\" / \"drop\" / \"error\"] Handling missing intervals needles. \"equals\" considers missing intervals needles exactly equal missing intervals haystack determining matching relationship . \"drop\" drops missing intervals needles result. \"error\" throws error intervals needles missing. single integer provided, represents value returned haystack column intervals needles missing. no_match Handling needles without match. \"drop\" drops needles zero matches result. \"error\" throws error needles zero matches. single integer provided, represents value returned haystack column values needles zero matches. default represents unmatched needle NA. remaining Handling haystack values needles never matched. \"drop\" drops remaining haystack values result. Typically, desired behavior care needles match. \"error\" throws error remaining haystack values. single integer provided (often NA), represents value returned needles column remaining haystack values needles never matched. Remaining haystack values always returned end result. multiple Handling needles multiple matches. needle: \"\" returns matches detected haystack. \"\" returns match detected haystack guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected haystack. \"last\" returns last match detected haystack. relationship Handling expected relationship needles haystack. expectations chosen list invalidated, error thrown. \"none\" perform relationship checks. \"one--one\" expects: value needles matches 1 value haystack. value haystack matches 1 value needles. \"one--many\" expects: value needles matches number values haystack. value haystack matches 1 value needles. \"many--one\" expects: value needles matches 1 value haystack. value haystack matches number values needles. \"many--many\" expects: value needles matches number values haystack. value haystack matches number values needles. performs checks, identical \"none\", provided allow explicit relationship know exists. \"warn-many--many\" assume known relationship, warn needles haystack many--many relationship (typically unexpected), encouraging either take closer look inputs make relationship explicit specifying \"many--many\". relationship applied filter multiple allow potential multiple matches filtered first. relationship handle cases zero matches. , see no_match remaining. closest [TRUE / FALSE] closest relationship returned? TRUE, return closest interval(s) haystack current value needles either precedes follows. Note multiple intervals can still returned ties, can resolved using multiple.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-locate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate relationships between two ivs — relation-locate","text":"data frame containing two integer columns named needles haystack.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/relation-locate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate relationships between two ivs — relation-locate","text":"","code":"x <- iv_pairs(   as.Date(c(\"2019-01-05\", \"2019-01-10\")),   as.Date(c(\"2019-01-07\", \"2019-01-15\")),   as.Date(c(\"2019-01-20\", \"2019-01-31\")) )  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> <iv<date>[3]> #> [1] [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-15) [2019-01-20, 2019-01-31) y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Find any overlap between `x` and `y` loc <- iv_locate_overlaps(x, y) loc #>   needles haystack #> 1       1        2 #> 2       1        3 #> 3       2        2 #> 4       2        3 #> 5       2        4 #> 6       3       NA  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-04, 2019-01-08) #> 2 [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-09) #> 3 [2019-01-07, 2019-01-15) [2019-01-04, 2019-01-08) #> 4 [2019-01-07, 2019-01-15) [2019-01-07, 2019-01-09) #> 5 [2019-01-07, 2019-01-15) [2019-01-10, 2019-01-20) #> 6 [2019-01-20, 2019-01-31)                 [NA, NA)  # Find where `x` contains `y` and drop results when there isn't a match loc <- iv_locate_overlaps(x, y, type = \"contains\", no_match = \"drop\") loc #>   needles haystack #> 1       1        3 #> 2       2        3  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-07, 2019-01-09) #> 2 [2019-01-07, 2019-01-15) [2019-01-07, 2019-01-09)  # Find where `x` precedes `y` loc <- iv_locate_precedes(x, y) loc #>   needles haystack #> 1       1        4 #> 2       1        5 #> 3       2        5 #> 4       3       NA  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-10, 2019-01-20) #> 2 [2019-01-05, 2019-01-10) [2019-01-15, 2019-01-20) #> 3 [2019-01-07, 2019-01-15) [2019-01-15, 2019-01-20) #> 4 [2019-01-20, 2019-01-31)                 [NA, NA)  # Filter down to find only the closest interval in `y` of all the intervals # where `x` preceded it loc <- iv_locate_precedes(x, y, closest = TRUE)  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-10, 2019-01-20) #> 2 [2019-01-07, 2019-01-15) [2019-01-15, 2019-01-20) #> 3 [2019-01-20, 2019-01-31)                 [NA, NA)  # Note that `closest` can result in duplicates if there is a tie. # `2019-01-20` appears as an end date twice in `haystack`. loc <- iv_locate_follows(x, y, closest = TRUE) loc #>   needles haystack #> 1       1        1 #> 2       2        1 #> 3       3        4 #> 4       3        5  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-01, 2019-01-03) #> 2 [2019-01-07, 2019-01-15) [2019-01-01, 2019-01-03) #> 3 [2019-01-20, 2019-01-31) [2019-01-10, 2019-01-20) #> 4 [2019-01-20, 2019-01-31) [2019-01-15, 2019-01-20)  # Force just one of the ties to be returned by using `multiple`. # Here we just request any of the ties, with no guarantee on which one. loc <- iv_locate_follows(x, y, closest = TRUE, multiple = \"any\") loc #>   needles haystack #> 1       1        1 #> 2       2        1 #> 3       3        4  iv_align(x, y, locations = loc) #>                    needles                 haystack #> 1 [2019-01-05, 2019-01-10) [2019-01-01, 2019-01-03) #> 2 [2019-01-07, 2019-01-15) [2019-01-01, 2019-01-03) #> 3 [2019-01-20, 2019-01-31) [2019-01-10, 2019-01-20)  # ---------------------------------------------------------------------------  a <- iv(NA, NA) b <- iv(c(NA, NA), c(NA, NA))  # By default, missing intervals in `needles` are seen as exactly equal to # missing intervals in `haystack`, which means that they overlap iv_locate_overlaps(a, b) #>   needles haystack #> 1       1        1 #> 2       1        2  # If you'd like missing intervals in `needles` to always be considered # unmatched, set `missing = NA` iv_locate_overlaps(a, b, missing = NA) #>   needles haystack #> 1       1       NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count relationships between a vector and an iv — vector-count","title":"Count relationships between a vector and an iv — vector-count","text":"family functions counts different types relationships vector iv. works similar base::match(), needles[] checks match haystack. iv_count_between() counts instances needles, vector, falls bounds haystack, iv. iv_count_includes() counts instances needles, iv, includes values haystack, vector. functions return integer vector size needles containing count times -th value needles contained match haystack.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count relationships between a vector and an iv — vector-count","text":"","code":"iv_count_between(needles, haystack, ..., missing = \"equals\", no_match = 0L)  iv_count_includes(needles, haystack, ..., missing = \"equals\", no_match = 0L)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count relationships between a vector and an iv — vector-count","text":"needles, haystack [vector, iv] iv_*_between(), needles vector haystack iv. iv_*_includes(), needles iv haystack vector. element needles represents value / interval match. haystack represents values / intervals match . ... dots future extensions must empty. missing [integer(1) / \"equals\" / \"error\"] Handling missing values needles. \"equals\" considers missing values needles exactly equal missing values haystack determining matching relationship . \"error\" throws error values needles missing. single integer value provided, represents count returned missing value needles. Use 0L force missing values never match. no_match [integer(1) / \"error\"] Handling needles without match. \"error\" throws error needles zero matches. single integer provided, represents count returned needle zero matches. default value gives unmatched needles count 0L.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count relationships between a vector and an iv — vector-count","text":"integer vector size needles.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count relationships between a vector and an iv — vector-count","text":"","code":"x <- as.Date(c(\"2019-01-05\", \"2019-01-10\", \"2019-01-07\", \"2019-01-20\"))  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> [1] \"2019-01-05\" \"2019-01-10\" \"2019-01-07\" \"2019-01-20\" y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Count the number of times `x` is between the intervals in `y` iv_count_between(x, y) #> [1] 1 1 2 0  # Count the number of times `y` includes a value from `x` iv_count_includes(y, x) #> [1] 0 2 1 1 0  # ---------------------------------------------------------------------------  a <- c(1, NA) b <- iv(c(NA, NA), c(NA, NA))  # By default, missing values in `needles` are treated as being exactly # equal to missing values in `haystack`, so the missing value in `a` is # considered between the missing interval in `b`. iv_count_between(a, b) #> [1] 0 2 iv_count_includes(b, a) #> [1] 1 1  # If you'd like to propagate missing values, set `missing = NA` iv_count_between(a, b, missing = NA) #> [1]  0 NA iv_count_includes(b, a, missing = NA) #> [1] NA NA  # If you'd like missing values to be treated as unmatched, set # `missing = 0L` iv_count_between(a, b, missing = 0L) #> [1] 0 0 iv_count_includes(b, a, missing = 0L) #> [1] 0 0"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect-pairwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","title":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","text":"family functions detects different types relationships vector iv pairwise. pairwise means -th value x compared -th value y. contrast iv_between(), works like base::%%. iv_pairwise_between() detects -th value x, vector, falls bounds -th value y, iv. iv_pairwise_includes() detects -th value x, iv, includes -th value y, vector. functions return logical vector size common size x y.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect-pairwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","text":"","code":"iv_pairwise_between(x, y)  iv_pairwise_includes(x, y)"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect-pairwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","text":"x, y [vector, iv] iv_pairwise_between(), x must vector y must iv. iv_pairwise_includes(), x must iv y must vector. x y recycled .","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect-pairwise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","text":"logical vector size common size x y.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect-pairwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise detect relationships between a vector and an iv — vector-detect-pairwise","text":"","code":"x <- as.Date(c(\"2019-01-01\", \"2019-01-08\", \"2019-01-21\"))  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-18\", \"2019-01-21\")) )  x #> [1] \"2019-01-01\" \"2019-01-08\" \"2019-01-21\" y #> <iv<date>[3]> #> [1] [2019-01-01, 2019-01-03) [2019-01-07, 2019-01-09) [2019-01-18, 2019-01-21)  # Does the i-th value of `x` fall between the i-th interval of `y`? iv_pairwise_between(x, y) #> [1]  TRUE  TRUE FALSE  # Does the i-th interval of `y` include the i-th value of `x`? iv_pairwise_includes(y, x) #> [1]  TRUE  TRUE FALSE  a <- c(1, NA, NA) b <- iv_pairs(c(NA, NA), c(3, 4), c(NA, NA))  # Missing intervals always propagate iv_pairwise_between(a, b) #> [1] NA NA NA iv_pairwise_includes(b, a) #> [1] NA NA NA"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect relationships between a vector and an iv — vector-detect","title":"Detect relationships between a vector and an iv — vector-detect","text":"family functions detects different types relationships vector iv. works similar base::%%, needles[] checks match haystack. iv_between() detects needles, vector, falls bounds haystack, iv. iv_includes() detects needles, iv, includes values haystack, vector. function returns logical vector size needles containing TRUE value needles matches value haystack FALSE otherwise.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect relationships between a vector and an iv — vector-detect","text":"","code":"iv_between(needles, haystack, ..., missing = \"equals\")  iv_includes(needles, haystack, ..., missing = \"equals\")"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect relationships between a vector and an iv — vector-detect","text":"needles, haystack [vector, iv] iv_*_between(), needles vector haystack iv. iv_*_includes(), needles iv haystack vector. element needles represents value / interval match. haystack represents values / intervals match . ... dots future extensions must empty. missing [logical(1) / \"equals\" / \"error\"] Handling missing values needles. \"equals\" considers missing values needles exactly equal missing values haystack determining matching relationship . Matched missing values needles result TRUE value result, unmatched missing values result FALSE value. \"error\" throws error values needles missing. single logical value provided, represents value returned result values needles missing. can force missing values unmatched setting FALSE, can force propagated setting NA.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect relationships between a vector and an iv — vector-detect","text":"logical vector size needles.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect relationships between a vector and an iv — vector-detect","text":"","code":"x <- as.Date(c(\"2019-01-05\", \"2019-01-10\", \"2019-01-07\", \"2019-01-20\"))  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> [1] \"2019-01-05\" \"2019-01-10\" \"2019-01-07\" \"2019-01-20\" y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Detect if the i-th location in `x` is between any intervals in `y` iv_between(x, y) #> [1]  TRUE  TRUE  TRUE FALSE  # Detect if the i-th location in `y` includes any value in `x` iv_includes(y, x) #> [1] FALSE  TRUE  TRUE  TRUE FALSE  # ---------------------------------------------------------------------------  a <- c(1, NA) b <- iv(c(NA, NA), c(NA, NA))  # By default, missing values in `needles` are treated as being exactly # equal to missing values in `haystack`, so the missing value in `a` is # considered between the missing interval in `b`. iv_between(a, b) #> [1] FALSE  TRUE iv_includes(b, a) #> [1] TRUE TRUE  # If you'd like to propagate missing values, set `missing = NA` iv_between(a, b, missing = NA) #> [1] FALSE    NA iv_includes(b, a, missing = NA) #> [1] NA NA  # If you'd like missing values to be treated as unmatched, set # `missing = FALSE` iv_between(a, b, missing = FALSE) #> [1] FALSE FALSE iv_includes(b, a, missing = FALSE) #> [1] FALSE FALSE"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-locate.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate relationships between a vector and an iv — vector-locate","title":"Locate relationships between a vector and an iv — vector-locate","text":"family functions locates different types relationships vector iv. works similar base::match(), needles[] checks match haystack. Unlike match(), matches returned, rather just first. iv_locate_between() locates needles, vector, falls bounds haystack, iv. iv_locate_includes() locates needles, iv, includes values haystack, vector. functions return two column data frame. needles column integer vector pointing locations needles. haystack column integer vector pointing locations haystack match.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-locate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate relationships between a vector and an iv — vector-locate","text":"","code":"iv_locate_between(   needles,   haystack,   ...,   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )  iv_locate_includes(   needles,   haystack,   ...,   missing = \"equals\",   no_match = NA_integer_,   remaining = \"drop\",   multiple = \"all\",   relationship = \"none\" )"},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-locate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate relationships between a vector and an iv — vector-locate","text":"needles, haystack [vector, iv] iv_*_between(), needles vector haystack iv. iv_*_includes(), needles iv haystack vector. element needles represents value / interval match. haystack represents values / intervals match . ... dots future extensions must empty. missing [integer(1) / \"equals\" / \"drop\" / \"error\"] Handling missing values needles. \"equals\" considers missing values needles exactly equal missing values haystack determining matching relationship . \"drop\" drops missing values needles result. \"error\" throws error values needles missing. single integer provided, represents value returned haystack column values needles missing. no_match Handling needles without match. \"drop\" drops needles zero matches result. \"error\" throws error needles zero matches. single integer provided, represents value returned haystack column values needles zero matches. default represents unmatched needle NA. remaining Handling haystack values needles never matched. \"drop\" drops remaining haystack values result. Typically, desired behavior care needles match. \"error\" throws error remaining haystack values. single integer provided (often NA), represents value returned needles column remaining haystack values needles never matched. Remaining haystack values always returned end result. multiple Handling needles multiple matches. needle: \"\" returns matches detected haystack. \"\" returns match detected haystack guarantees match returned. often faster \"first\" \"last\" just need detect least one match. \"first\" returns first match detected haystack. \"last\" returns last match detected haystack. relationship Handling expected relationship needles haystack. expectations chosen list invalidated, error thrown. \"none\" perform relationship checks. \"one--one\" expects: value needles matches 1 value haystack. value haystack matches 1 value needles. \"one--many\" expects: value needles matches number values haystack. value haystack matches 1 value needles. \"many--one\" expects: value needles matches 1 value haystack. value haystack matches number values needles. \"many--many\" expects: value needles matches number values haystack. value haystack matches number values needles. performs checks, identical \"none\", provided allow explicit relationship know exists. \"warn-many--many\" assume known relationship, warn needles haystack many--many relationship (typically unexpected), encouraging either take closer look inputs make relationship explicit specifying \"many--many\". relationship applied filter multiple allow potential multiple matches filtered first. relationship handle cases zero matches. , see no_match remaining.","code":""},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-locate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate relationships between a vector and an iv — vector-locate","text":"data frame containing two integer columns named needles haystack.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/ivs/dev/reference/vector-locate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate relationships between a vector and an iv — vector-locate","text":"","code":"x <- as.Date(c(\"2019-01-05\", \"2019-01-10\", \"2019-01-07\", \"2019-01-20\"))  y <- iv_pairs(   as.Date(c(\"2019-01-01\", \"2019-01-03\")),   as.Date(c(\"2019-01-04\", \"2019-01-08\")),   as.Date(c(\"2019-01-07\", \"2019-01-09\")),   as.Date(c(\"2019-01-10\", \"2019-01-20\")),   as.Date(c(\"2019-01-15\", \"2019-01-20\")) )  x #> [1] \"2019-01-05\" \"2019-01-10\" \"2019-01-07\" \"2019-01-20\" y #> <iv<date>[5]> #> [1] [2019-01-01, 2019-01-03) [2019-01-04, 2019-01-08) [2019-01-07, 2019-01-09) #> [4] [2019-01-10, 2019-01-20) [2019-01-15, 2019-01-20)  # Find any location where `x` is between the intervals in `y` loc <- iv_locate_between(x, y) loc #>   needles haystack #> 1       1        2 #> 2       2        4 #> 3       3        2 #> 4       3        3 #> 5       4       NA  iv_align(x, y, locations = loc) #>      needles                 haystack #> 1 2019-01-05 [2019-01-04, 2019-01-08) #> 2 2019-01-10 [2019-01-10, 2019-01-20) #> 3 2019-01-07 [2019-01-04, 2019-01-08) #> 4 2019-01-07 [2019-01-07, 2019-01-09) #> 5 2019-01-20                 [NA, NA)  # Find any location where `y` includes the values in `x` loc <- iv_locate_includes(y, x) loc #>   needles haystack #> 1       1       NA #> 2       2        1 #> 3       2        3 #> 4       3        3 #> 5       4        2 #> 6       5       NA  iv_align(y, x, locations = loc) #>                    needles   haystack #> 1 [2019-01-01, 2019-01-03)       <NA> #> 2 [2019-01-04, 2019-01-08) 2019-01-05 #> 3 [2019-01-04, 2019-01-08) 2019-01-07 #> 4 [2019-01-07, 2019-01-09) 2019-01-07 #> 5 [2019-01-10, 2019-01-20) 2019-01-10 #> 6 [2019-01-15, 2019-01-20)       <NA>  # Drop values in `x` without a match loc <- iv_locate_between(x, y, no_match = \"drop\") loc #>   needles haystack #> 1       1        2 #> 2       2        4 #> 3       3        2 #> 4       3        3  iv_align(x, y, locations = loc) #>      needles                 haystack #> 1 2019-01-05 [2019-01-04, 2019-01-08) #> 2 2019-01-10 [2019-01-10, 2019-01-20) #> 3 2019-01-07 [2019-01-04, 2019-01-08) #> 4 2019-01-07 [2019-01-07, 2019-01-09)  # ---------------------------------------------------------------------------  a <- c(1, NA) b <- iv(c(NA, NA), c(NA, NA))  # By default, missing values in `needles` are treated as being exactly # equal to missing values in `haystack`, so the missing value in `a` is # considered between the missing interval in `b`. iv_locate_between(a, b) #>   needles haystack #> 1       1       NA #> 2       2        1 #> 3       2        2 iv_locate_includes(b, a) #>   needles haystack #> 1       1        2 #> 2       2        2  # If you'd like missing values in `needles` to always be considered # unmatched, set `missing = NA` iv_locate_between(a, b, missing = NA) #>   needles haystack #> 1       1       NA #> 2       2       NA iv_locate_includes(b, a, missing = NA) #>   needles haystack #> 1       1       NA #> 2       2       NA"},{"path":"https://davisvaughan.github.io/ivs/dev/news/index.html","id":"ivs-0109000","dir":"Changelog","previous_headings":"","what":"ivs 0.1.0.9000","title":"ivs 0.1.0.9000","text":"family “set” functions renamed include set_ prefix, example, iv_union() now iv_set_union(). done align new family vctrs set functions, like vec_set_union(), reduce ambiguity new iv_diff() helper iv_difference() (now iv_set_difference()). old names deprecated, removed future release (#35). iv_complement() -> iv_set_complement() iv_union() -> iv_set_union() iv_intersect() -> iv_set_intersect() iv_difference() -> iv_set_difference() iv_symmetric_difference() -> iv_set_symmetric_difference() changes made iv_pairwise_*() functions share suffixes. New family functions perform inverse iv_between(), .e. rather detecting needles[], vector value, falls intervals haystack, iv, detect needles[], interval, includes value haystack, vector. functions : iv_includes(), iv_locate_includes(), iv_count_includes(), iv_pairwise_includes() (#41). New family functions identifying interval containers, intervals aren’t contained within interval. functions : iv_containers(), iv_identify_containers(), iv_identify_container(), iv_locate_containers() (#20). New iv_diff() generating iv existing vector strictly increasing order (#17). New Examples vignette links Stack Overflow questions solved ivs. View locally vignette(\"examples\", package = \"ivs\"). vec_ptype() vec_ptype_finalise() methods added iv class. result slightly better performance combining many ivs together (#27). iv_locate_overlaps(), iv_locate_precedes(), iv_locate_follows(), iv_locate_between(), iv_locate_includes() gained relationship argument underlying engine, vctrs::vec_locate_matches() (#45). iv_proxy() now returns input unchanged doesn’t implement S3 method, rather erroring. combination is_iv(), provides way check input implements proxy method implement different behaviors depending result. iv(), incomplete value propagation now done start < end check, fixes inconsistent edge case (#36). can now combine iv containing unspecified components iv (#33). \"iv\" class name renamed specific \"ivs_iv\" better insulate potential collisions classes packages (#25). Improved call reported errors thrown ivs (#23). Added NEWS.md file track changes package.","code":""}]
