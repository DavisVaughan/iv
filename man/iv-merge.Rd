% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/merge.R
\name{iv-merge}
\alias{iv-merge}
\alias{iv_merge}
\alias{iv_replace_merged}
\alias{iv_locate_merge_bounds}
\alias{iv_locate_merge_groups}
\title{Merge}
\usage{
iv_merge(x, ..., abutting = TRUE)

iv_replace_merged(x, ..., abutting = TRUE)

iv_locate_merge_bounds(x, ..., abutting = TRUE)

iv_locate_merge_groups(x, ..., abutting = TRUE)
}
\arguments{
\item{x}{\verb{[iv]}

An interval vector.}

\item{...}{These dots are for future extensions and must be empty.}

\item{abutting}{\verb{[logical(1)]}

Should abutting intervals be merged?

If \code{TRUE}, \verb{[a, b)} and \verb{[b, c)} will merge as \verb{[a, c)}. If \code{FALSE}, they
will be kept separate. To be a minimal interval vector, all abutting
intervals must be merged.}
}
\value{
For \code{iv_merge()}, an iv with the same type as \code{x}.

For \code{iv_replace_merged()}, an iv with the same type and size as \code{x}.

For \code{iv_locate_merge_bounds()}, a two column data frame with \code{start} and
\code{end} integer columns.

For \code{iv_locate_merge_groups()}, a two column data frame with a \code{key} column
containing the result of \code{iv_locate_merge_bounds()} and a \code{loc} list-column
containing integer vectors.
}
\description{
This family of functions revolves around merging the intervals within a
single iv.
\itemize{
\item \code{iv_merge()} merges overlapping or abutting intervals in \code{x}.
\item \code{iv_replace_merged()} replaces each interval in \code{x} with the merged
interval that it maps to. This is particularly useful alongside
\code{\link[dplyr:group_by]{dplyr::group_by()}}.
\item \code{iv_locate_merge_bounds()} returns locations for slicing the \code{\link[=iv_start]{iv_start()}}
and \code{\link[=iv_end]{iv_end()}} of \code{x} to generate the merged result.
\item \code{iv_locate_merge_groups()} returns a two column data frame with a \code{key}
column containing the result of \code{iv_locate_merge_bounds()} and a \code{loc}
list-column containing integer vectors that map each element of \code{x} to the
merged interval that it falls in.
}

Optionally, you can choose \emph{not} to merge abutting intervals with
\code{abutting = FALSE}, which can be useful if you'd like to retain those
boundaries.
\subsection{Minimal interval vectors}{

\code{iv_merge()} is particularly useful because it can generate a \emph{minimal}
interval vector, which covers the range of an interval vector in the most
compact form possible. In particular, a minimal interval vector:
\itemize{
\item Has no overlapping intervals
\item Has no abutting intervals
\item Is ordered on both \code{start} and \code{end}
}

A minimal interval vector is allowed to have a single missing interval,
which is located at the end of the vector.
}
}
\examples{
library(dplyr, warn.conflicts = FALSE)

x <- iv_pairs(
  c(1, 5),
  c(2, 3),
  c(NA, NA),
  c(5, 6),
  c(NA, NA),
  c(9, 12),
  c(11, 14)
)
x

# Merging removes all redundancy while still covering the full range
# of values that were originally represented. If any missing intervals
# are present, a single one is retained.
iv_merge(x)

# Abutting intervals are typically merged, but you can choose not to merge
# them if you want to retain those boundaries
iv_merge(x, abutting = FALSE)

# `iv_replace_merged()` is useful alongside `group_by()` and `summarize()`
df <- tibble(x = x)
df <- mutate(df, u = iv_replace_merged(x))
df

df \%>\%
  group_by(u) \%>\%
  summarize(n = n())

# The real workhorse here is `iv_locate_merge_groups()`, which returns
# information on where to slice `x` to get the merged result, and which
# observations of `x` belong to which merged interval
iv_locate_merge_groups(x)
}
