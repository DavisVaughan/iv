% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/union.R
\name{iv-union}
\alias{iv-union}
\alias{iv_union}
\alias{iv_replace_union}
\alias{iv_locate_union}
\alias{iv_locate_union_groups}
\title{Union}
\usage{
iv_union(x, ..., keep_abutting = FALSE)

iv_replace_union(x, ..., keep_abutting = FALSE)

iv_locate_union(x, ..., keep_abutting = FALSE)

iv_locate_union_groups(x, ..., keep_abutting = FALSE)
}
\arguments{
\item{x}{\verb{[iv]}

An interval vector.}

\item{...}{These dots are for future extensions and must be empty.}

\item{keep_abutting}{\verb{[logical(1)]}

Should abutting intervals be kept separate?

If \code{FALSE}, \verb{[a, b)} and \verb{[b, c)} will join as \verb{[a, c)}. If \code{TRUE}, they
will be kept separate. To be a minimal interval vector, all abutting
intervals must be merged.}
}
\description{
This family of functions revolves around taking the union of intervals
within a single interval vector.
\itemize{
\item \code{iv_union()} returns the union of all the intervals in \code{x}.
\item \code{iv_replace_union()} replaces each value in \code{x} with its union interval.
This is particularly useful alongside \code{\link[dplyr:group_by]{dplyr::group_by()}}.
\item \code{iv_locate_union()} returns locations for slicing the \code{\link[=iv_start]{iv_start()}} and
\code{\link[=iv_end]{iv_end()}} of \code{x} to generate the union.
\item \code{iv_locate_union_groups()} returns the same locations as
\code{iv_locate_union()} along with a list-column of group locations that maps
each element of \code{x} to its union interval.
}

Optionally, you can choose to keep abutting intervals separate with
\code{keep_abutting}, which can be useful if you'd like to retain those
boundaries.
\subsection{Minimal interval vectors}{

\code{iv_union()} is particularly useful because it can generate a \emph{minimal}
interval vector, which covers the range of an interval vector in the most
compact form possible. In particular, a minimal interval vector:
\itemize{
\item Has no overlapping intervals
\item Has no abutting intervals
\item Is ordered on both \code{start} and \code{end}
}

A minimal interval vector is allowed to have a single missing interval,
which is located at the end of the vector.
}
}
\examples{
library(dplyr, warn.conflicts = FALSE)

x <- iv_pairs(
  c(1, 5),
  c(2, 3),
  c(NA, NA),
  c(5, 6),
  c(NA, NA),
  c(9, 12),
  c(11, 14)
)
x

# The union removes all redundancy while still covering the full range
# of values that were originally represented. If any missing intervals
# are present, a single one is retained.
iv_union(x)

# Abutting intervals can be kept separate if you want to
# retain those boundaries
iv_union(x, keep_abutting = TRUE)

# `iv_replace_union()` is useful alongside `group_by()` and `summarize()`
df <- tibble(x = x)
df <- mutate(df, u = iv_replace_union(x))
df

df \%>\%
  group_by(u) \%>\%
  summarize(n = n())

# The real workhorse here is `iv_locate_union_groups()`, which returns
# information on where to slice `x` to get the union, and which observations
# of `x` belong to which union interval
iv_locate_union_groups(x)
}
