% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/between.R
\name{iv_locate_between}
\alias{iv_locate_between}
\title{Locate where a vector falls between an iv}
\usage{
iv_locate_between(
  needles,
  haystack,
  ...,
  missing = "error",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all"
)
}
\arguments{
\item{needles, haystack}{\verb{[vector, iv]}

\code{needles} should be a vector and \code{haystack} should be an iv. \code{needles}
should have the same type as the start/end components of \code{haystack}.
\itemize{
\item Each element of \code{needles} represents the value to search for.
\item \code{haystack} represents the intervals to search in.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{missing}{\verb{[integer(1) / "match" / "drop" / "error"]}

Handling of missing values in \code{needles}.
\itemize{
\item \code{"match"} matches missing values in \code{needles} to missing intervals in
\code{haystack}. Missing values will be matched exactly.
\item \code{"drop"} drops missing values in \code{needles} from the result.
\item \code{"error"} throws an error if any values in \code{needles} are missing.
This is the default.
\item If a single integer is provided, this represents the value returned in
the \code{haystack} column for values in \code{needles} that are missing.
}}

\item{no_match}{Handling of \code{needles} without a match.
\itemize{
\item \code{"drop"} drops \code{needles} with zero matches from the result.
\item \code{"error"} throws an error if any \code{needles} have zero matches.
\item If a single integer is provided, this represents the value returned in
the \code{haystack} column for observations of \code{needles} that have zero
matches. The default represents an unmatched needle with \code{NA}.
}}

\item{remaining}{Handling of \code{haystack} values that \code{needles} never matched.
\itemize{
\item \code{"drop"} drops remaining \code{haystack} values from the result.
Typically, this is the desired behavior if you only care when \code{needles}
has a match.
\item \code{"error"} throws an error if there are any remaining \code{haystack}
values.
\item If a single integer is provided (often \code{NA}), this represents the value
returned in the \code{needles} column for the remaining \code{haystack} values
that \code{needles} never matched. Remaining \code{haystack} values are always
returned at the end of the result.
}}

\item{multiple}{Handling of \code{needles} with multiple matches. For each needle:
\itemize{
\item \code{"all"} returns all matches detected in \code{haystack}.
\item \code{"any"} returns any match detected in \code{haystack} with no guarantees on
which match will be returned. It is often faster than \code{"first"} and
\code{"last"} if you just need to detect if there is at least one match.
\item \code{"first"} returns the first match detected in \code{haystack}.
\item \code{"last"} returns the last match detected in \code{haystack}.
\item \code{"warning"} throws a warning if multiple matches are detected, but
otherwise falls back to \code{"all"}.
\item \code{"error"} throws an error if multiple matches are detected.
}}
}
\value{
A data frame containing two integer columns named \code{needles} and \code{haystack}.
}
\description{
\code{iv_locate_between()} locates where \code{needles}, a vector, falls between the
bounds of \code{haystack}, an iv. It works similar to \code{\link[base:match]{base::match()}}, where
\code{needles[i]} checks for a match in all of \code{haystack}. Unlike \code{match()}, \emph{all}
matches are returned, rather than just the first.

This function returns a two column data frame. The \code{needles} column is an
integer vector pointing to locations in \code{needles}. The \code{haystack} column is
an integer vector pointing to locations in \code{haystack} with a match.
\subsection{Missing values}{

Unlike \code{match()}, missing values in \code{needles} force an error to be thrown
by default. \code{match()} matches using equality, so it is typically clear that
you also want missing values to match exactly. The relationships implemented
here match using inequalities, and it is much less clear what the desired
result is for missing values. If you have missing values that you'd
like to match exactly, set \code{missing = "match"}. If you have missing values
that you'd like to force to be unmatched, set \code{missing = NA}.
}
}
\examples{
library(vctrs)

join <- function(x, y, loc) {
  data_frame(
    x = vec_slice(x, loc$needles),
    y = vec_slice(y, loc$haystack)
  )
}

x <- as.Date(c("2019-01-05", "2019-01-10", "2019-01-07", "2019-01-20"))

y <- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Find any location where `x` is between the intervals in `y`
loc <- iv_locate_between(x, y)
loc

join(x, y, loc)

# Drop values in `x` without a match
loc <- iv_locate_between(x, y, no_match = "drop")
loc

join(x, y, loc)

# ---------------------------------------------------------------------------

a <- c(NA, NA)
b <- iv(c(NA, NA), c(NA, NA))

# By default, missing values in `needles` force an error to be thrown
try(iv_locate_between(a, b))

# If you'd like missing values to match exactly, regardless of `type`,
# use `missing = "match"`
iv_locate_between(a, b, missing = "match")

# If you'd like missing values in `needles` to always be considered
# unmatched, set `missing = NA`
iv_locate_between(a, b, missing = NA)
}
\seealso{
\link[=relation-locate]{Locating relationships}

\link[=iv_detect_between]{Detect when a vector falls between an iv}

\link[=iv_detect_parallel_between]{Detecting when a vector falls between an iv in parallel}
}
