% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/relation.R
\name{relation-detect-parallel}
\alias{relation-detect-parallel}
\alias{iv_detect_parallel_overlaps}
\alias{iv_detect_parallel_precedes}
\alias{iv_detect_parallel_follows}
\title{Detect a relationship in parallel between two ivs}
\usage{
iv_detect_parallel_overlaps(x, y, ..., type = "any", missing = "error")

iv_detect_parallel_precedes(x, y, ..., missing = "error")

iv_detect_parallel_follows(x, y, ..., missing = "error")
}
\arguments{
\item{x, y}{\verb{[iv]}

A pair of interval vectors.

These will be recycled against each other and cast to the same type.}

\item{...}{These dots are for future extensions and must be empty.}

\item{type}{\verb{[character(1)]}

The type of relationship to find. One of:
\itemize{
\item \code{"any"}: Finds any overlap whatsoever between an interval in \code{needles}
and an interval in \code{haystack}.
\item \code{"within"}: Finds when an interval in \code{needles} is completely within
(or equal to) an interval in \code{haystack}.
\item \code{"contains"}: Finds when an interval in \code{needles} completely contains
(or equals) an interval in \code{haystack}.
\item \code{"equals"}: Finds when an interval in \code{needles} is exactly equal to
an interval in \code{haystack}.
\item \code{"starts"}: Finds when the start of an interval in \code{needles} matches the
start of an interval in \code{haystack}.
\item \code{"ends"}: Finds when the end of an interval in \code{needles} matches the end
of an interval in \code{haystack}.
}}

\item{missing}{\verb{[logical(1) / "match" / "error"]}

Handling of missing intervals in \code{x} or \code{y}.
\itemize{
\item \code{"match"} matches missing intervals in \code{x} to missing intervals in
\code{y}. Regardless of \code{type}, if both intervals are missing, then this
results in \code{TRUE}, otherwise it results in \code{FALSE}.
\item \code{"error"} throws an error if any intervals are missing.
This is the default.
\item If a single logical value is provided, this represents the value returned
in the i-th element of the result if missing intervals are present in the
i-th interval of \code{x} or \code{y}. You can force missing intervals to be
unmatched by setting this to \code{FALSE}, and you can force them to be
propagated by setting this to \code{NA}.
}}
}
\value{
A logical vector the same size as the common size of \code{x} and \code{y}.
}
\description{
This family of functions detects different types of relationships between
two ivs \emph{in parallel}, where parallel means that the i-th interval of
\code{x} is compared against the i-th interval of \code{y}. This is in contrast to
\code{\link[=iv_detect_overlaps]{iv_detect_overlaps()}}, which works more like \link[base:match]{base::\%in\%}.
\itemize{
\item \code{iv_detect_parallel_overlaps()} detects a specific \code{type} of overlap
between the i-th interval of \code{x} and the i-th interval of \code{y}.
\item \code{iv_detect_parallel_precedes()} detects if the i-th interval of \code{x}
precedes (i.e. comes before) the i-th interval of \code{y}.
\item \code{iv_detect_parallel_follows()} detects if the i-th interval of \code{x}
follows (i.e. comes after) the i-th interval of \code{y}.
}

These functions return a logical vector the same size as the common size of
\code{x} and \code{y}.
\subsection{Missing intervals}{

Missing intervals in \code{x} or \code{y} force an error to be thrown by default, as
it is unclear what the desired result is when missing intervals are involved.
This is consistent with \code{\link[=iv_detect_overlaps]{iv_detect_overlaps()}}. If you'd like to match
missing intervals exactly, set \code{missing = "match"}. If you'd like missing
intervals to be unmatched, set \code{missing = FALSE}. If you'd like missing
intervals to be propagated, set \code{missing = NA}.
}
}
\examples{
library(vctrs)

x <- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y <- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-18", "2019-01-21"))
)

x
y

# Does the i-th interval of `x` overlap the i-th interval of `y`?
iv_detect_parallel_overlaps(x, y)

# Does the i-th interval of `x` contain the i-th interval of `y`?
iv_detect_parallel_overlaps(x, y, type = "contains")

# Does the i-th interval of `x` follow the i-th interval of `y`?
iv_detect_parallel_follows(x, y)

# ---------------------------------------------------------------------------

a <- iv(c(1, NA), c(2, NA))
b <- iv(c(NA, NA), c(NA, NA))

# Missing intervals error by default
try(iv_detect_parallel_overlaps(a, b))

# If you'd like missing intervals to match exactly, set `missing = "match"`
iv_detect_parallel_overlaps(a, b, missing = "match")

# If you'd like missing intervals to be treated as unmatched, set
# `missing = FALSE`
iv_detect_parallel_overlaps(a, b, missing = FALSE)

# If you'd like to propagate missing intervals, set `missing = NA`
iv_detect_parallel_overlaps(a, b, missing = NA)
}
\seealso{
\link[=relation-locate]{Locating relationships}

\link[=relation-detect]{Detecting relationships}

\link[=allen-relation-locate]{Locating relations from Allen's Interval Algebra}
}
